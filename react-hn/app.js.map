{"version":3,"sources":["webpack:///app.js","webpack:///C:/repos/react-hn/src/app.jsx","webpack:///C:/repos/react-hn/src/stores/SettingsStore.js","webpack:///C:/repos/react-hn/src/services/HNService.js","webpack:///C:/repos/react-hn/src/Spinner.jsx","webpack:///C:/repos/react-hn/src/utils/buildClassName.js","webpack:///C:/repos/react-hn/src/utils/extend.js","webpack:///C:/repos/react-hn/src/utils/setTitle.js","webpack:///C:/repos/react-hn/src/stores/StoryStore.js","webpack:///C:/repos/react-hn/src/stores/UpdatesStore.js","webpack:///C:/repos/react-hn/src/utils/constants.js","webpack:///C:/repos/react-hn/src/utils/pluralise.js","webpack:///C:/repos/react-hn/src/mixins/CommentMixin.jsx","webpack:///C:/repos/react-hn/src/mixins/ItemMixin.jsx","webpack:///C:/repos/react-hn/src/stores/CommentThreadStore.js","webpack:///C:/repos/react-hn/src/stores/StoryCommentThreadStore.js","webpack:///C:/repos/react-hn/src/Comment.jsx","webpack:///C:/repos/react-hn/src/Paginator.jsx","webpack:///C:/repos/react-hn/src/mixins/ListItemMixin.jsx","webpack:///C:/repos/react-hn/src/mixins/PageNumberMixin.js","webpack:///C:/repos/react-hn/src/stores/ItemStore.js","webpack:///C:/repos/react-hn/src/utils/pageCalc.js","webpack:///C:/repos/react-hn/src/utils/storage.js","webpack:///C:/repos/react-hn/src/DisplayComment.jsx","webpack:///C:/repos/react-hn/src/DisplayListItem.jsx","webpack:///C:/repos/react-hn/src/Item.jsx","webpack:///C:/repos/react-hn/src/PermalinkedComment.jsx","webpack:///C:/repos/react-hn/src/PollOption.jsx","webpack:///C:/repos/react-hn/src/Settings.jsx","webpack:///C:/repos/react-hn/src/Stories.jsx","webpack:///C:/repos/react-hn/src/StoryListItem.jsx","webpack:///C:/repos/react-hn/src/Updates.jsx","webpack:///C:/repos/react-hn/src/UserProfile.jsx","webpack:///C:/repos/react-hn/src/utils/cancellableDebounce.js"],"names":["webpackJsonp","module","exports","__webpack_require__","storiesHandler","route","type","limit","title","React","createClass","render","createElement","Stories","_extends","this","props","key","updatesHandler","Updates","Object","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","_require","IndexRoute","Link","Route","Router","StoryStore","UpdatesStore","SettingsStore","PermalinkedComment","Item","Settings","UserProfile","App","displayName","getInitialState","showSettings","componentWillMount","load","loadSession","window","addEventListener","handleBeforeUnload","componentWillUnmount","removeEventListener","saveSession","toggleSettings","e","preventDefault","setState","state","className","onClick","src","width","height","alt","to","activeClassName","tabIndex","onKeyPress","children","href","NotFound","Ask","Comments","Jobs","New","Show","Top","routes","path","component","document","getElementById","extend","storage","STORAGE_KEY","autoCollapse","replyLinks","showDead","showDeleted","titleFontSize","listSpacing","json","get","JSON","parse","save","set","stringify","fetchItem","id","cb","itemRef","once","snapshot","val","fetchItems","ids","addItem","item","items","push","forEach","storiesRef","api","child","userRef","updatesRef","Firebase","Spinner","getDefaultProps","size","spacing","bounceSize","bounceStyle","marginRight","style","Number","buildClassName","staticClassName","conditionalClassNames","classNames","classNameKeys","keys","l","join","dest","src1","src2","setTitle","SITE_TITLE","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","populateStoryList","idCache","storyList","storyLists","itemCache","parseJSON","defaultValue","_createClass","defineProperties","descriptor","defineProperty","protoProps","staticProps","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","undefined","Function","getOwnPropertyDescriptor","getPrototypeOf","EventEmitter","HNService","firebaseRef","_EventEmitter","onStorage","bind","onStoriesUpdated","stories","index","emit","getState","on","off","getItem","sessionStorage","sortByTimeDesc","a","b","time","cacheObjToSortedArray","obj","arr","map","sort","populateUpdates","updates","comments","processCacheObj","updatesCache","cacheObj","splice","UPDATES_CACHE_SIZE","Math","max","handleUpdateItems","deleted","updateItemTypes","comment","job","poll","story","start","stop","getUpdates","getComment","getStory","removeListener","ITEMS_PER_PAGE","pluralise","howMany","suffixes","split","TimeAgo","ItemStore","CommentMixin","fetchAncestors","_this","fetchCommentAncestors","result","isMounted","op","renderCommentLoading","level","loadingSpinner","delayed","renderCommentDeleted","options","renderError","renderCollapseControl","collapsed","toggleCollapse","renderCommentMeta","dead","collapsible","childCounts","newComments","by","date","link","renderCommentText","dangerouslySetInnerHTML","__html","text","replyLink","parseHost","url","parts","hostname","slice","shift","ItemMixin","renderItemMeta","extraContent","itemDate","Date","score","descendants","renderItemTitle","hasURL","fontSize","CommentThreadStore","onCommentsChanged","itemId","isNew","isCollapsed","getChildCounts","childCount","newCommentCount","nodes","nextNodes","nodeChildren","apply","commentAdded","commentDeleted","siblings","indexOf","commentId","loadState","lastVisit","commentCount","maxCommentId","StoryCommentThreadStore","startedLoading","now","parents","loading","expectedComments","kids","itemDescendantCount","initialState","prevMaxCommentId","isFirstVisit","cached","checkLoadCompletion","debounce","numberOfCommentsChanged","firstLoadComplete","collapseThreadsWithoutNewComments","_storeState","itemUpdated","commentDelayed","commentDied","adjustExpectedComments","change","newCommentIds","hasNewComments","shouldCollapse","commentIds","nextCommentIds","childCommentIds","markAsRead","dispose","cancel","ReactFireMixin","cx","Comment","mixins","propTypes","PropTypes","number","isRequired","bool","threadStore","instanceOf","bindFirebaseRef","clearDelayTimeout","componentDidUpdate","prevProps","prevState","prevKids","bindAsObject","handleFirebaseRefCancelled","timeout","unbind","setTimeout","forceUpdate","clearTimeout","Comment--collapsed","Comment--dead","Comment--new","Paginator","_onClick","scrollTo","page","hasNext","query","ListItemMixin","getNewCommentCount","threadState","renderListItem","ListItem--dead","marginBottom","PageNumberMixin","getPageNumber","location","test","setImmediate","fetchCommentParent","parentId","commentParentLookup","titleCache","itemCount","cacheHits","processCommentParent","cachedItem","getCachedItem","getCachedStory","startTime","timeTaken","pageCalc","pageNum","pageSize","numItems","startIndex","endIndex","min","localStorage","DisplayComment","DisplayListItem","timeUnitsAgo","unit","suffix","PollOption","params","handleCommentsChanged","componentWillReceiveProps","nextProps","componentWillUpdate","nextState","kidDiff","payload","Item--dead","formatter","_setTitle","commentLoaded","context","router","replaceWith","pollopt","componentDidMount","refs","container","getDOMNode","focus","onChange","el","name","checked","stopPropagation","ref","htmlFor","step","StoryListItem","string","store","addListener","handleUpdate","update","dummyItems","renderItems","rendered","initLiveItem","updateThreadState","filterDead","filterUpdates","filter","handleUpdates","user","createdDate","created","toDateString","karma","delay","about","cancellableDebounce","func","wait","immediate","args","timestamp","later","last","debounced","callNow"],"mappings":"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","file":"app.js","sourcesContent":["webpackJsonp([1],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\t__webpack_require__(122);\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar _require = __webpack_require__(26);\n\t\n\tvar IndexRoute = _require.IndexRoute;\n\tvar Link = _require.Link;\n\tvar Route = _require.Route;\n\tvar Router = _require.Router;\n\t\n\tvar StoryStore = __webpack_require__(44);\n\tvar UpdatesStore = __webpack_require__(45);\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar PermalinkedComment = __webpack_require__(127);\n\tvar Item = __webpack_require__(126);\n\tvar Settings = __webpack_require__(129);\n\tvar Stories = __webpack_require__(130);\n\tvar Updates = __webpack_require__(132);\n\tvar UserProfile = __webpack_require__(133);\n\t\n\tvar App = React.createClass({\n\t  displayName: 'App',\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      showSettings: false\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    SettingsStore.load();\n\t    StoryStore.loadSession();\n\t    UpdatesStore.loadSession();\n\t    window.addEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t\n\t  /**\n\t   * Give stores a chance to persist data to sessionStorage in case this is a\n\t   * refresh or an external link in the same tab.\n\t   */\n\t  handleBeforeUnload: function handleBeforeUnload() {\n\t    StoryStore.saveSession();\n\t    UpdatesStore.saveSession();\n\t  },\n\t\n\t  toggleSettings: function toggleSettings(e) {\n\t    e.preventDefault();\n\t    this.setState({ showSettings: !this.state.showSettings });\n\t  },\n\t\n\t  render: function render() {\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'App', onClick: this.state.showSettings && this.toggleSettings },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'App__wrap' },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'App__header' },\n\t          React.createElement('img', { src: 'logo.png', width: '16', height: '16', alt: '' }),\n\t          ' ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/news', activeClassName: 'active', className: 'App__homelink' },\n\t            'React HN'\n\t          ),\n\t          ' ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/newest', activeClassName: 'active' },\n\t            'new'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/newcomments', activeClassName: 'active' },\n\t            'comments'\n\t          ),\n\t          ' ',\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/show', activeClassName: 'active' },\n\t            'show'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/ask', activeClassName: 'active' },\n\t            'ask'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            Link,\n\t            { to: '/jobs', activeClassName: 'active' },\n\t            'jobs'\n\t          ),\n\t          React.createElement(\n\t            'a',\n\t            { className: 'App__settings', tabIndex: '0', onClick: this.toggleSettings, onKeyPress: this.toggleSettings },\n\t            this.state.showSettings ? 'hide settings' : 'settings'\n\t          ),\n\t          this.state.showSettings && React.createElement(Settings, { key: 'settings' })\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'App__content' },\n\t          this.props.children\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'App__footer' },\n\t          'react-hn v' + (\"1.2.1\") + ' | ',\n\t          React.createElement(\n\t            'a',\n\t            { href: 'https://github.com/insin/react-hn' },\n\t            'insin/react-hn'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tvar NotFound = React.createClass({\n\t  displayName: 'NotFound',\n\t\n\t  render: function render() {\n\t    return React.createElement(\n\t      'h2',\n\t      null,\n\t      'Not found'\n\t    );\n\t  }\n\t});\n\t\n\tfunction storiesHandler(route, type, limit, title) {\n\t  return React.createClass({\n\t    render: function render() {\n\t      return React.createElement(Stories, _extends({}, this.props, { key: route, route: route, type: type, limit: limit, title: title }));\n\t    }\n\t  });\n\t}\n\t\n\tfunction updatesHandler(type) {\n\t  return React.createClass({\n\t    render: function render() {\n\t      return React.createElement(Updates, _extends({}, this.props, { key: type, type: type }));\n\t    }\n\t  });\n\t}\n\t\n\tvar Ask = storiesHandler('ask', 'askstories', 200, 'Ask');\n\tvar Comments = updatesHandler('comments');\n\tvar Jobs = storiesHandler('jobs', 'jobstories', 200, 'Jobs');\n\tvar New = storiesHandler('newest', 'newstories', 500, 'New Links');\n\tvar Show = storiesHandler('show', 'showstories', 200, 'Show');\n\tvar Top = storiesHandler('news', 'topstories', 500);\n\t\n\tvar routes = React.createElement(\n\t  Route,\n\t  { path: '/', component: App },\n\t  React.createElement(IndexRoute, { component: Top }),\n\t  React.createElement(Route, { path: 'news', component: Top }),\n\t  React.createElement(Route, { path: 'newest', component: New }),\n\t  React.createElement(Route, { path: 'show', component: Show }),\n\t  React.createElement(Route, { path: 'ask', component: Ask }),\n\t  React.createElement(Route, { path: 'jobs', component: Jobs }),\n\t  React.createElement(Route, { path: 'item/:id', component: Item }),\n\t  React.createElement(Route, { path: 'job/:id', component: Item }),\n\t  React.createElement(Route, { path: 'poll/:id', component: Item }),\n\t  React.createElement(Route, { path: 'story/:id', component: Item }),\n\t  React.createElement(Route, { path: 'comment/:id', component: PermalinkedComment }),\n\t  React.createElement(Route, { path: 'newcomments', component: Comments }),\n\t  React.createElement(Route, { path: 'user/:id', component: UserProfile }),\n\t  React.createElement(Route, { path: '*', component: NotFound })\n\t);\n\t\n\tReact.render(React.createElement(Router, { routes: routes }), document.getElementById('app'));\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar extend = __webpack_require__(33);\n\tvar storage = __webpack_require__(92);\n\t\n\tvar STORAGE_KEY = 'settings';\n\t\n\tvar SettingsStore = {\n\t  autoCollapse: true,\n\t  replyLinks: true,\n\t  showDead: false,\n\t  showDeleted: false,\n\t  titleFontSize: 18,\n\t  listSpacing: 16,\n\t\n\t  load: function load() {\n\t    var json = storage.get(STORAGE_KEY);\n\t    if (json) {\n\t      extend(this, JSON.parse(json));\n\t    }\n\t  },\n\t\n\t  save: function save() {\n\t    storage.set(STORAGE_KEY, JSON.stringify({\n\t      autoCollapse: this.autoCollapse,\n\t      replyLinks: this.replyLinks,\n\t      showDead: this.showDead,\n\t      showDeleted: this.showDeleted,\n\t      titleFontSize: this.titleFontSize,\n\t      listSpacing: this.listSpacing\n\t    }));\n\t  }\n\t};\n\t\n\tmodule.exports = SettingsStore;\n\n/***/ },\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Firebase = __webpack_require__(93);\n\t\n\tvar api = new Firebase('https://hacker-news.firebaseio.com/v0');\n\t\n\tfunction fetchItem(id, cb) {\n\t  itemRef(id).once('value', function (snapshot) {\n\t    cb(snapshot.val());\n\t  });\n\t}\n\t\n\tfunction fetchItems(ids, cb) {\n\t  var items = [];\n\t  ids.forEach(function (id) {\n\t    fetchItem(id, addItem);\n\t  });\n\t  function addItem(item) {\n\t    items.push(item);\n\t    if (items.length >= ids.length) {\n\t      cb(items);\n\t    }\n\t  }\n\t}\n\t\n\tfunction storiesRef(path) {\n\t  return api.child(path);\n\t}\n\t\n\tfunction itemRef(id) {\n\t  return api.child('item/' + id);\n\t}\n\t\n\tfunction userRef(id) {\n\t  return api.child('user/' + id);\n\t}\n\t\n\tfunction updatesRef() {\n\t  return api.child('updates/items');\n\t}\n\t\n\tmodule.exports = {\n\t  fetchItem: fetchItem,\n\t  fetchItems: fetchItems,\n\t  storiesRef: storiesRef,\n\t  itemRef: itemRef,\n\t  userRef: userRef,\n\t  updatesRef: updatesRef\n\t};\n\n/***/ },\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\t// TODO Implement GIF-based fallback for IE9 and another non-animating browsers\n\t//      See https://github.com/tobiasahlin/SpinKit for how-to\n\tvar Spinner = React.createClass({\n\t  displayName: 'Spinner',\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return { size: 6, spacing: 2 };\n\t  },\n\t\n\t  render: function render() {\n\t    var bounceSize = this.props.size + 'px';\n\t    var bounceStyle = { height: bounceSize, width: bounceSize, marginRight: this.props.spacing + 'px' };\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Spinner', style: { width: (Number(this.props.size) + Number(this.props.spacing)) * 3 + 'px' } },\n\t      React.createElement('div', { className: 'bounce1', style: bounceStyle }),\n\t      React.createElement('div', { className: 'bounce2', style: bounceStyle }),\n\t      React.createElement('div', { className: 'bounce3', style: bounceStyle })\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Spinner;\n\n/***/ },\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Creates a className string including some class names conditionally.\n\t * @param {string=} staticClassName class name(s) which should always be\n\t *   included.\n\t * @param {Object.<string, *>} conditionalClassNames an object mapping class\n\t *   names to a value which indicates if the class name should be included -\n\t *   class names will be included if their corresponding value is truthy.\n\t * @return {string}\n\t */\n\t'use strict';\n\t\n\tfunction buildClassName(staticClassName, conditionalClassNames) {\n\t  var classNames = [];\n\t  if (typeof conditionalClassNames == 'undefined') {\n\t    conditionalClassNames = staticClassName;\n\t  } else {\n\t    classNames.push(staticClassName);\n\t  }\n\t  var classNameKeys = Object.keys(conditionalClassNames);\n\t  for (var i = 0, l = classNameKeys.length; i < l; i++) {\n\t    if (conditionalClassNames[classNameKeys[i]]) {\n\t      classNames.push(classNameKeys[i]);\n\t    }\n\t  }\n\t  return classNames.join(' ');\n\t}\n\t\n\tmodule.exports = buildClassName;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction extend(dest, src1, src2) {\n\t  var props = Object.keys(src1);\n\t  for (var i = 0, l = props.length; i < l; i++) {\n\t    dest[props[i]] = src1[props[i]];\n\t  }\n\t  if (src2) {\n\t    props = Object.keys(src2);\n\t    for (i = 0, l = props.length; i < l; i++) {\n\t      dest[props[i]] = src2[props[i]];\n\t    }\n\t  }\n\t  return dest;\n\t}\n\t\n\tmodule.exports = extend;\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(46);\n\t\n\tvar SITE_TITLE = _require.SITE_TITLE;\n\t\n\tfunction setTitle(title) {\n\t  document.title = title ? title + ' | ' + SITE_TITLE : SITE_TITLE;\n\t}\n\t\n\tmodule.exports = setTitle;\n\n/***/ },\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _require = __webpack_require__(62);\n\t\n\tvar EventEmitter = _require.EventEmitter;\n\t\n\tvar HNService = __webpack_require__(12);\n\t\n\tvar extend = __webpack_require__(33);\n\t\n\t/**\n\t * Firebase reference used to stream updates - only one StoryStore instance can\n\t * be active at a time.\n\t */\n\tvar firebaseRef = null;\n\t\n\t// Cache objects shared among StoryStore instances, also accessible via static\n\t// functions on the StoryStore constructor.\n\t\n\t/**\n\t * Story ids by type, in rank order. Persisted to sessionStorage.\n\t * @type Object.<type, Array.<id>>\n\t */\n\tvar idCache = {};\n\t\n\t/**\n\t * Item cache. Persisted to sessionStorage.\n\t * @type Object.<id, item>\n\t */\n\tvar itemCache = {};\n\t\n\t/**\n\t * Story items in rank order for display, by type.\n\t * @type Object.<type, Array.<item>>\n\t */\n\tvar storyLists = {};\n\t\n\t/**\n\t * Populate the story list for the given story type from the cache.\n\t */\n\tfunction populateStoryList(type) {\n\t  var ids = idCache[type];\n\t  var storyList = storyLists[type];\n\t  for (var i = 0, l = ids.length; i < l; i++) {\n\t    storyList[i] = itemCache[ids[i]] || null;\n\t  }\n\t}\n\t\n\tfunction parseJSON(json, defaultValue) {\n\t  return json ? JSON.parse(json) : defaultValue;\n\t}\n\t\n\tvar StoryStore = (function (_EventEmitter) {\n\t  _inherits(StoryStore, _EventEmitter);\n\t\n\t  function StoryStore(type) {\n\t    _classCallCheck(this, StoryStore);\n\t\n\t    _get(Object.getPrototypeOf(StoryStore.prototype), 'constructor', this).call(this);\n\t    this.type = type;\n\t\n\t    // Ensure cache objects for this type are initialised\n\t    if (!(type in idCache)) {\n\t      idCache[type] = [];\n\t    }\n\t    if (!(type in storyLists)) {\n\t      storyLists[type] = [];\n\t      populateStoryList(type);\n\t    }\n\t\n\t    // Pre-bind event handlers per instance\n\t    this.onStorage = this.onStorage.bind(this);\n\t    this.onStoriesUpdated = this.onStoriesUpdated.bind(this);\n\t  }\n\t\n\t  // Static, cache-related functions\n\t\n\t  _createClass(StoryStore, [{\n\t    key: 'getState',\n\t    value: function getState() {\n\t      return {\n\t        ids: idCache[this.type],\n\t        stories: storyLists[this.type]\n\t      };\n\t    }\n\t  }, {\n\t    key: 'itemUpdated',\n\t    value: function itemUpdated(item, index) {\n\t      storyLists[this.type][index] = item;\n\t      itemCache[item.id] = item;\n\t    }\n\t\n\t    /**\n\t     * Emit an item id event if a storage key corresponding to an item in the\n\t     * cache has changed.\n\t     */\n\t  }, {\n\t    key: 'onStorage',\n\t    value: function onStorage(e) {\n\t      if (itemCache[e.key]) {\n\t        this.emit(e.key);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Handle story id snapshots from Firebase.\n\t     */\n\t  }, {\n\t    key: 'onStoriesUpdated',\n\t    value: function onStoriesUpdated(snapshot) {\n\t      idCache[this.type] = snapshot.val();\n\t      populateStoryList(this.type);\n\t      this.emit('update', this.getState());\n\t    }\n\t  }, {\n\t    key: 'start',\n\t    value: function start() {\n\t      firebaseRef = HNService.storiesRef(this.type);\n\t      firebaseRef.on('value', this.onStoriesUpdated);\n\t      window.addEventListener('storage', this.onStorage);\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop() {\n\t      if (firebaseRef !== null) {\n\t        firebaseRef.off();\n\t        firebaseRef = null;\n\t      }\n\t      window.removeEventListener('storage', this.onStorage);\n\t    }\n\t  }]);\n\t\n\t  return StoryStore;\n\t})(EventEmitter);\n\t\n\textend(StoryStore, {\n\t  /**\n\t   * Get an item from the cache.\n\t   */\n\t  getItem: function getItem(id) {\n\t    return itemCache[id] || null;\n\t  },\n\t\n\t  /**\n\t   * Deserialise caches from sessionStorage.\n\t   */\n\t  loadSession: function loadSession() {\n\t    idCache = parseJSON(window.sessionStorage.idCache, {});\n\t    itemCache = parseJSON(window.sessionStorage.itemCache, {});\n\t  },\n\t\n\t  /**\n\t   * Serialise caches to sessionStorage as JSON.\n\t   */\n\t  saveSession: function saveSession() {\n\t    window.sessionStorage.idCache = JSON.stringify(idCache);\n\t    window.sessionStorage.itemCache = JSON.stringify(itemCache);\n\t  }\n\t});\n\t\n\tmodule.exports = StoryStore;\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(62).EventEmitter;\n\t\n\tvar HNService = __webpack_require__(12);\n\t\n\tvar _require = __webpack_require__(46);\n\t\n\tvar UPDATES_CACHE_SIZE = _require.UPDATES_CACHE_SIZE;\n\t\n\tvar extend = __webpack_require__(33);\n\t\n\t/**\n\t * Firebase reference used to stream updates.\n\t */\n\tvar updatesRef = null;\n\t\n\t/**\n\t * Contains item id -> item cache objects. Persisted to sessionStorage.\n\t * @prop .comments {Object.<id,item>} comments cache.\n\t * @prop .stories {Object.<id,item>} story cache.\n\t */\n\tvar updatesCache = null;\n\t\n\t/**\n\t * Lists of items in reverse chronological order for display.\n\t * @prop .comments {Array.<item>} comment updates.\n\t * @prop .stories {Array.<item>} story updates.\n\t */\n\tvar updates = {};\n\t\n\tfunction sortByTimeDesc(a, b) {\n\t  return b.time - a.time;\n\t}\n\t\n\tfunction cacheObjToSortedArray(obj) {\n\t  var arr = Object.keys(obj).map(function (id) {\n\t    return obj[id];\n\t  });\n\t  arr.sort(sortByTimeDesc);\n\t  return arr;\n\t}\n\t\n\t/**\n\t * Populate lists of updates for display from the cache.\n\t */\n\tfunction populateUpdates() {\n\t  updates.comments = processCacheObj(updatesCache.comments);\n\t  updates.stories = processCacheObj(updatesCache.stories);\n\t}\n\t\n\t/**\n\t * Create an array of items from a cache object, sorted in reverse chronological\n\t * order. Evict the oldest items from the cache if it's grown above\n\t * UPDATES_CACHE_SIZE.\n\t */\n\tfunction processCacheObj(cacheObj) {\n\t  var arr = cacheObjToSortedArray(cacheObj);\n\t  arr.splice(UPDATES_CACHE_SIZE, Math.max(0, arr.length - UPDATES_CACHE_SIZE)).forEach(function (item) {\n\t    delete cacheObj[item.id];\n\t  });\n\t  return arr;\n\t}\n\t\n\t/**\n\t * Lookup to filter out any items which appear in the updates feed which can't\n\t * be displayed by the Updates component.\n\t */\n\tvar updateItemTypes = {\n\t  comment: true,\n\t  job: true,\n\t  poll: true,\n\t  story: true\n\t};\n\t\n\t/**\n\t * Process incoming items from the update stream.\n\t */\n\tfunction handleUpdateItems(items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    var item = items[i];\n\t    // Silently ignore deleted items (because irony)\n\t    if (item.deleted) {\n\t      continue;\n\t    }\n\t\n\t    if (typeof updateItemTypes[item.type] == 'undefined') {\n\t      if (false) {\n\t        console.warn(\"An item which can't be displayed by the Updates component was \" + 'received in the updates stream: ' + JSON.stringify(item));\n\t      }\n\t      continue;\n\t    }\n\t\n\t    if (item.type === 'comment') {\n\t      updatesCache.comments[item.id] = item;\n\t    } else {\n\t      updatesCache.stories[item.id] = item;\n\t    }\n\t  }\n\t\n\t  populateUpdates();\n\t  UpdatesStore.emit('updates', updates);\n\t}\n\t\n\tvar UpdatesStore = extend(new EventEmitter(), {\n\t  loadSession: function loadSession() {\n\t    var json = window.sessionStorage.updates;\n\t    updatesCache = json ? JSON.parse(json) : { comments: {}, stories: {} };\n\t    populateUpdates();\n\t  },\n\t\n\t  saveSession: function saveSession() {\n\t    window.sessionStorage.updates = JSON.stringify(updatesCache);\n\t  },\n\t\n\t  start: function start() {\n\t    if (updatesRef === null) {\n\t      updatesRef = HNService.updatesRef();\n\t      updatesRef.on('value', function (snapshot) {\n\t        HNService.fetchItems(snapshot.val(), handleUpdateItems);\n\t      });\n\t    }\n\t  },\n\t\n\t  stop: function stop() {\n\t    updatesRef.off();\n\t    updatesRef = null;\n\t  },\n\t\n\t  getUpdates: function getUpdates() {\n\t    return updates;\n\t  },\n\t\n\t  getItem: function getItem(id) {\n\t    return updatesCache.comments[id] || updatesCache.stories[id] || null;\n\t  },\n\t\n\t  getComment: function getComment(id) {\n\t    return updatesCache.comments[id] || null;\n\t  },\n\t\n\t  getStory: function getStory(id) {\n\t    return updatesCache.stories[id] || null;\n\t  }\n\t});\n\tUpdatesStore.off = UpdatesStore.removeListener;\n\t\n\tmodule.exports = UpdatesStore;\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  ITEMS_PER_PAGE: 30,\n\t  SITE_TITLE: 'React HN',\n\t  UPDATES_CACHE_SIZE: 500\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction pluralise(howMany, suffixes) {\n\t  return (suffixes || ',s').split(',')[howMany === 1 ? 0 : 1];\n\t}\n\t\n\tmodule.exports = pluralise;\n\n/***/ },\n/* 48 */,\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar _require = __webpack_require__(26);\n\t\n\tvar Link = _require.Link;\n\t\n\tvar TimeAgo = __webpack_require__(37);\n\t\n\tvar ItemStore = __webpack_require__(90);\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar Spinner = __webpack_require__(20);\n\t\n\tvar pluralise = __webpack_require__(47);\n\t\n\tvar CommentMixin = {\n\t  fetchAncestors: function fetchAncestors(comment) {\n\t    var _this = this;\n\t\n\t    ItemStore.fetchCommentAncestors(comment, function (result) {\n\t      if (false) {\n\t        console.info('fetchAncestors(' + comment.id + ') took ' + result.timeTaken + ' ms for ' + result.itemCount + ' item' + pluralise(result.itemCount) + ' with ' + result.cacheHits + ' cache hit' + pluralise(result.cacheHits) + ' (' + (result.cacheHits / result.itemCount * 100).toFixed(1) + '%)');\n\t      }\n\t      if (!_this.isMounted()) {\n\t        if (false) {\n\t          console.info(\"...but the comment isn't mounted\");\n\t        }\n\t        // Too late - the comment or the user has moved elsewhere\n\t        return;\n\t      }\n\t      _this.setState({\n\t        parent: result.parent,\n\t        op: result.op\n\t      });\n\t    });\n\t  },\n\t\n\t  renderCommentLoading: function renderCommentLoading(comment) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Comment Comment--loading Comment--level' + this.props.level },\n\t      (this.props.loadingSpinner || comment.delayed) && React.createElement(Spinner, { size: '20' }),\n\t      comment.delayed && React.createElement(\n\t        'div',\n\t        { className: 'Comment__text' },\n\t        'Unable to load comment – this usually indicates the author has configured a delay. Trying again in 30 seconds.'\n\t      )\n\t    );\n\t  },\n\t\n\t  renderCommentDeleted: function renderCommentDeleted(comment, options) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: options.className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Comment__meta' },\n\t          '[deleted] | ',\n\t          React.createElement(\n\t            'a',\n\t            { href: 'https://news.ycombinator.com/item?id=' + comment.id },\n\t            'view on Hacker News'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  },\n\t\n\t  renderError: function renderError(comment, options) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: options.className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Comment__meta' },\n\t          '[error] | comment is ',\n\t          JSON.stringify(comment),\n\t          ' | ',\n\t          React.createElement(\n\t            'a',\n\t            { href: 'https://news.ycombinator.com/item?id=' + options.id },\n\t            'view on Hacker News'\n\t          )\n\t        )\n\t      )\n\t    );\n\t  },\n\t\n\t  renderCollapseControl: function renderCollapseControl(collapsed) {\n\t    return React.createElement(\n\t      'span',\n\t      { className: 'Comment__collapse', onClick: this.toggleCollapse, onKeyPress: this.toggleCollapse, tabIndex: '0' },\n\t      '[',\n\t      collapsed ? '+' : '–',\n\t      ']'\n\t    );\n\t  },\n\t\n\t  /**\n\t   * @param options.collapsible {Boolean} if true, assumes this.toggleCollspse()\n\t   * @param options.collapsed {Boolean}\n\t   * @param options.link {Boolean}\n\t   * @param options.parent {Boolean} if true, assumes this.state.parent\n\t   * @param options.op {Boolean} if true, assumes this.state.op\n\t   * @param options.childCounts {Object} with .children and .newComments\n\t   */\n\t  renderCommentMeta: function renderCommentMeta(comment, options) {\n\t    if (comment.dead && !SettingsStore.showDead) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Comment__meta' },\n\t        options.collapsible && this.renderCollapseControl(options.collapsed),\n\t        options.collapsible && ' ',\n\t        '[dead]',\n\t        options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren'),\n\t        options.childCounts && options.childCounts.newComments > 0 && ', ',\n\t        options.childCounts && options.childCounts.newComments > 0 && React.createElement(\n\t          'em',\n\t          null,\n\t          options.childCounts.newComments,\n\t          ' new'\n\t        ),\n\t        options.childCounts && ')'\n\t      );\n\t    }\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Comment__meta' },\n\t      options.collapsible && this.renderCollapseControl(options.collapsed),\n\t      options.collapsible && ' ',\n\t      React.createElement(\n\t        Link,\n\t        { to: '/user/' + comment.by, className: 'Comment__user' },\n\t        comment.by\n\t      ),\n\t      ' ',\n\t      React.createElement(TimeAgo, { date: comment.time * 1000 }),\n\t      options.link && ' | ',\n\t      options.link && React.createElement(\n\t        Link,\n\t        { to: '/comment/' + comment.id },\n\t        'link'\n\t      ),\n\t      options.parent && ' | ',\n\t      options.parent && React.createElement(\n\t        Link,\n\t        { to: '/' + this.state.parent.type + '/' + comment.parent },\n\t        'parent'\n\t      ),\n\t      options.op && ' | on: ',\n\t      options.op && React.createElement(\n\t        Link,\n\t        { to: '/' + this.state.op.type + '/' + this.state.op.id },\n\t        this.state.op.title\n\t      ),\n\t      comment.dead && ' | [dead]',\n\t      options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren'),\n\t      options.childCounts && options.childCounts.newComments > 0 && ', ',\n\t      options.childCounts && options.childCounts.newComments > 0 && React.createElement(\n\t        'em',\n\t        null,\n\t        options.childCounts.newComments,\n\t        ' new'\n\t      ),\n\t      options.childCounts && ')'\n\t    );\n\t  },\n\t\n\t  renderCommentText: function renderCommentText(comment, options) {\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Comment__text' },\n\t      !comment.dead || SettingsStore.showDead ? React.createElement('div', { dangerouslySetInnerHTML: { __html: comment.text } }) : '[dead]',\n\t      SettingsStore.replyLinks && options.replyLink && !comment.dead && React.createElement(\n\t        'p',\n\t        null,\n\t        React.createElement(\n\t          'a',\n\t          { href: 'https://news.ycombinator.com/reply?id=' + comment.id },\n\t          'reply'\n\t        )\n\t      )\n\t    );\n\t  }\n\t};\n\t\n\tmodule.exports = CommentMixin;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar _require = __webpack_require__(26);\n\t\n\tvar Link = _require.Link;\n\t\n\tvar TimeAgo = __webpack_require__(37);\n\t\n\tvar SettingsStore = __webpack_require__(7);\n\tvar pluralise = __webpack_require__(47);\n\t\n\tvar parseHost = (function () {\n\t  var a = document.createElement('a');\n\t  return function (url) {\n\t    a.href = url;\n\t    var parts = a.hostname.split('.').slice(-3);\n\t    if (parts[0] === 'www') {\n\t      parts.shift();\n\t    }\n\t    return parts.join('.');\n\t  };\n\t})();\n\t\n\t/**\n\t * Reusable logic for displaying an item.\n\t */\n\tvar ItemMixin = {\n\t  /**\n\t   * Render an item's metadata bar.\n\t   */\n\t  renderItemMeta: function renderItemMeta(item, extraContent) {\n\t    var itemDate = new Date(item.time * 1000);\n\t\n\t    if (item.type == 'job') {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Item__meta' },\n\t        React.createElement(TimeAgo, { date: itemDate, className: 'Item__time' })\n\t      );\n\t    }\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Item__meta' },\n\t      React.createElement(\n\t        'span',\n\t        { className: 'Item__score' },\n\t        item.score,\n\t        ' point',\n\t        pluralise(item.score)\n\t      ),\n\t      ' ',\n\t      React.createElement(\n\t        'span',\n\t        { className: 'Item__by' },\n\t        'by ',\n\t        React.createElement(\n\t          Link,\n\t          { to: '/user/' + item.by },\n\t          item.by\n\t        )\n\t      ),\n\t      ' ',\n\t      React.createElement(TimeAgo, { date: itemDate, className: 'Item__time' }),\n\t      ' | ',\n\t      React.createElement(\n\t        Link,\n\t        { to: '/' + item.type + '/' + item.id },\n\t        item.descendants > 0 ? item.descendants + ' comment' + pluralise(item.descendants) : 'discuss'\n\t      ),\n\t      extraContent\n\t    );\n\t  },\n\t\n\t  /**\n\t   * Render an item's title bar.\n\t   */\n\t  renderItemTitle: function renderItemTitle(item) {\n\t    var hasURL = !!item.url;\n\t    var title;\n\t    if (item.dead) {\n\t      title = '[dead] ' + item.title;\n\t    } else {\n\t      title = hasURL ? React.createElement(\n\t        'a',\n\t        { href: item.url },\n\t        item.title\n\t      ) : React.createElement(\n\t        Link,\n\t        { to: '/' + item.type + '/' + item.id },\n\t        item.title\n\t      );\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Item__title', style: { fontSize: SettingsStore.titleFontSize } },\n\t      title,\n\t      hasURL && ' ',\n\t      hasURL && React.createElement(\n\t        'span',\n\t        { className: 'Item__host' },\n\t        '(',\n\t        parseHost(item.url),\n\t        ')'\n\t      )\n\t    );\n\t  }\n\t};\n\t\n\tmodule.exports = ItemMixin;\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar extend = __webpack_require__(33);\n\t\n\tfunction CommentThreadStore(item, onCommentsChanged) {\n\t  this.itemId = item.id;\n\t  this.onCommentsChanged = onCommentsChanged;\n\t\n\t  /**\n\t   * Lookup from a comment id to its child comment ids.\n\t   * @type {Object.<id,Array.<Number>>}\n\t   */\n\t  this.children = {};\n\t  this.children[item.id] = [];\n\t\n\t  /**\n\t   * Lookup for new comment ids. Will only contain true.\n\t   * @type {Object.<id,Boolean>}\n\t   */\n\t  this.isNew = {};\n\t\n\t  /**\n\t   * Lookup for collapsed state of comment ids. May contain true or false.\n\t   * @type {Object.<id,Boolean>}\n\t   */\n\t  this.isCollapsed = {};\n\t}\n\t\n\textend(CommentThreadStore.prototype, {\n\t  /**\n\t   * Get counts of children and new comments under the given comment.\n\t   * @return .children {Number}\n\t   * @return .newComments {Number}\n\t   */\n\t  getChildCounts: function getChildCounts(comment) {\n\t    var childCount = 0;\n\t    var newCommentCount = 0;\n\t    var nodes = [comment.id];\n\t\n\t    while (nodes.length) {\n\t      var nextNodes = [];\n\t      for (var i = 0, l = nodes.length; i < l; i++) {\n\t        var nodeChildren = this.children[nodes[i]];\n\t        if (nodeChildren.length) {\n\t          nextNodes.push.apply(nextNodes, nodeChildren);\n\t        }\n\t      }\n\t      for (i = 0, l = nextNodes.length; i < l; i++) {\n\t        if (this.isNew[nextNodes[i]]) {\n\t          newCommentCount++;\n\t        }\n\t      }\n\t      childCount += nextNodes.length;\n\t      nodes = nextNodes;\n\t    }\n\t\n\t    return {\n\t      children: childCount,\n\t      newComments: newCommentCount\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Register a comment's appearance in the thread.\n\t   */\n\t  commentAdded: function commentAdded(comment) {\n\t    if (comment.deleted) {\n\t      return;\n\t    }\n\t\n\t    this.children[comment.id] = [];\n\t    this.children[comment.parent].push(comment.id);\n\t  },\n\t\n\t  /**\n\t   * Register a comment's deletion from the thread.\n\t   */\n\t  commentDeleted: function commentDeleted(comment) {\n\t    // Comments which initially failed to load (null from Firebase API) can be\n\t    // deleted by the time the API catches up.\n\t    if (!comment) {\n\t      return;\n\t    }\n\t\n\t    var siblings = this.children[comment.parent];\n\t    siblings.splice(siblings.indexOf(comment.id), 1);\n\t  },\n\t\n\t  toggleCollapse: function toggleCollapse(commentId) {\n\t    this.isCollapsed[commentId] = !this.isCollapsed[commentId];\n\t    this.onCommentsChanged({ type: 'collapse' });\n\t  }\n\t});\n\t\n\tmodule.exports = CommentThreadStore;\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar CommentThreadStore = __webpack_require__(60);\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar debounce = __webpack_require__(134);\n\tvar extend = __webpack_require__(33);\n\tvar pluralise = __webpack_require__(47);\n\tvar storage = __webpack_require__(92);\n\t\n\t/**\n\t * Load persisted comment thread state.\n\t * @return .lastVisit {Date} null if the item hasn't been visited before.\n\t * @return .commentCount {Number} 0 if the item hasn't been visited before.\n\t * @return .maxCommentId {Number} 0 if the item hasn't been visited before.\n\t */\n\tfunction loadState(itemId) {\n\t  var json = storage.get(itemId);\n\t  if (json) {\n\t    return JSON.parse(json);\n\t  }\n\t  return {\n\t    lastVisit: null,\n\t    commentCount: 0,\n\t    maxCommentId: 0\n\t  };\n\t}\n\t\n\tfunction StoryCommentThreadStore(item, onCommentsChanged, options) {\n\t  CommentThreadStore.call(this, item, onCommentsChanged);\n\t  this.startedLoading = Date.now();\n\t\n\t  /** Lookup from a comment id to its parent comment id. */\n\t  this.parents = {};\n\t  /** The number of comments which have loaded. */\n\t  this.commentCount = 0;\n\t  /** The number of new comments which have loaded. */\n\t  this.newCommentCount = 0;\n\t  /** The max comment id seen by the store. */\n\t  this.maxCommentId = 0;\n\t  /** Has the comment thread finished loading? */\n\t  this.loading = true;\n\t  /** The number of comments we're expecting to load. */\n\t  this.expectedComments = item.kids ? item.kids.length : 0;\n\t  /**\n\t   * The number of descendants the story has according to the API.\n\t   * This count includes deleted comments, which aren't accessible via the API,\n\t   * so a thread with deleted comments (example story id: 9273709) will never\n\t   * load this number of comments\n\t   * However, we still need to persist the last known descendant count in order\n\t   * to determine how many new comments there are when displaying the story on a\n\t   * list page.\n\t   */\n\t  this.itemDescendantCount = item.descendants;\n\t\n\t  var initialState = loadState(item.id);\n\t  /** Time of last visit to the story. */\n\t  this.lastVisit = initialState.lastVisit;\n\t  /** Max comment id on the last visit - determines which comments are new. */\n\t  this.prevMaxCommentId = initialState.maxCommentId;\n\t  /** Is this the user's first time viewing the story? */\n\t  this.isFirstVisit = initialState.lastVisit === null;\n\t\n\t  // Trigger an immediate check for thread load completion if the item was not\n\t  // retrieved from the cache, so is the latest version. This completes page\n\t  // loading immediately for items which have no comments yet.\n\t  if (!options.cached) {\n\t    this.checkLoadCompletion();\n\t  }\n\t}\n\t\n\tStoryCommentThreadStore.loadState = loadState;\n\t\n\tStoryCommentThreadStore.prototype = extend(Object.create(CommentThreadStore.prototype), {\n\t  constructor: StoryCommentThreadStore,\n\t\n\t  /**\n\t   * Callback to the item component with updated comment counts, debounced as\n\t   * comments will be loading frequently on initial load.\n\t   */\n\t  numberOfCommentsChanged: debounce(function () {\n\t    this.onCommentsChanged({ type: 'number' });\n\t  }, 123),\n\t\n\t  /**\n\t   * If we don't have a last visit time stored for an item, it must have been\n\t   * visited for the first time. Once it finishes loading, establish the last\n\t   * visit time and max comment id which will be used to track and display new\n\t   * comments.\n\t   */\n\t  firstLoadComplete: function firstLoadComplete() {\n\t    this.lastVisit = Date.now();\n\t    this.prevMaxCommentId = this.maxCommentId;\n\t    this.isFirstVisit = false;\n\t    this.onCommentsChanged({ type: 'first_load_complete' });\n\t  },\n\t\n\t  /**\n\t   * Check whether the number of comments has reached the expected number yet.\n\t   */\n\t  checkLoadCompletion: function checkLoadCompletion() {\n\t    if (this.loading && this.commentCount >= this.expectedComments) {\n\t      if (false) {\n\t        console.info('Initial load of ' + this.commentCount + ' comment' + pluralise(this.commentCount) + ' for ' + this.itemId + ' took ' + ((Date.now() - this.startedLoading) / 1000).toFixed(2) + 's');\n\t      }\n\t      this.loading = false;\n\t      if (this.isFirstVisit) {\n\t        this.firstLoadComplete();\n\t      } else if (SettingsStore.autoCollapse && this.newCommentCount > 0) {\n\t        this.collapseThreadsWithoutNewComments();\n\t      }\n\t      this._storeState();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Persist comment thread state.\n\t   */\n\t  _storeState: function _storeState() {\n\t    storage.set(this.itemId, JSON.stringify({\n\t      lastVisit: Date.now(),\n\t      commentCount: this.itemDescendantCount,\n\t      maxCommentId: this.maxCommentId\n\t    }));\n\t  },\n\t\n\t  /**\n\t   * The item this comment thread belongs to got updated.\n\t   */\n\t  itemUpdated: function itemUpdated(item) {\n\t    this.itemDescendantCount = item.descendants;\n\t  },\n\t\n\t  /**\n\t   * A comment got loaded initially or added later.\n\t   */\n\t  commentAdded: function commentAdded(comment) {\n\t    // Deleted comments don't count towards the comment count\n\t    if (comment.deleted) {\n\t      // Adjust the number of comments expected during the initial page load.\n\t      if (this.loading) {\n\t        this.expectedComments--;\n\t        this.checkLoadCompletion();\n\t      }\n\t      return;\n\t    }\n\t\n\t    CommentThreadStore.prototype.commentAdded.call(this, comment);\n\t\n\t    // Dead comments don't contribute to the comment count if showDead is off\n\t    if (comment.dead && !SettingsStore.showDead) {\n\t      this.expectedComments--;\n\t    } else {\n\t      this.commentCount++;\n\t    }\n\t    // Add the number of kids the comment has to the expected total for the\n\t    // initial load.\n\t    if (this.loading && comment.kids) {\n\t      this.expectedComments += comment.kids.length;\n\t    }\n\t    // Register the comment as new if it's new, unless it's dead and showDead is off\n\t    if (this.prevMaxCommentId > 0 && comment.id > this.prevMaxCommentId && (!comment.dead || SettingsStore.showDead)) {\n\t      this.newCommentCount++;\n\t      this.isNew[comment.id] = true;\n\t    }\n\t    // Keep track of the biggest comment id seen\n\t    if (comment.id > this.maxCommentId) {\n\t      this.maxCommentId = comment.id;\n\t    }\n\t    // We don't want the story to be part of the comment parent hierarchy\n\t    if (comment.parent !== this.itemId) {\n\t      this.parents[comment.id] = comment.parent;\n\t    }\n\t\n\t    this.numberOfCommentsChanged();\n\t    if (this.loading) {\n\t      this.checkLoadCompletion();\n\t    }\n\t  },\n\t\n\t  /**\n\t   * A comment which hasn't loaded yet is being delayed.\n\t   */\n\t  commentDelayed: function commentDelayed(commentId) {\n\t    // Don't wait for delayed comments\n\t    this.expectedComments--;\n\t  },\n\t\n\t  /**\n\t   * A comment which wasn't previously deleted became deleted.\n\t   */\n\t  commentDeleted: function commentDeleted(comment) {\n\t    CommentThreadStore.prototype.commentDeleted.call(this, comment);\n\t    this.commentCount--;\n\t    if (this.isNew[comment.id]) {\n\t      this.newCommentCount--;\n\t      delete this.isNew[comment.id];\n\t    }\n\t    delete this.parents[comment.id];\n\t    // Trigger debounced callbacks\n\t    this.numberOfCommentsChanged();\n\t  },\n\t\n\t  /**\n\t   * A comment which wasn't previously dead became dead.\n\t   */\n\t  commentDied: function commentDied(comment) {\n\t    if (!SettingsStore.showDead) {\n\t      this.commentCount--;\n\t      if (this.isNew[comment.id]) {\n\t        this.newCommentCount--;\n\t        delete this.isNew[comment.id];\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Change the expected number of comments if an update was received during\n\t   * initial loding and trigger a re-check of loading completion.\n\t   */\n\t  adjustExpectedComments: function adjustExpectedComments(change) {\n\t    this.expectedComments += change;\n\t    this.checkLoadCompletion();\n\t  },\n\t\n\t  collapseThreadsWithoutNewComments: function collapseThreadsWithoutNewComments() {\n\t    // Create an id lookup for comments which have a new comment as one of their\n\t    // descendants. New comments themselves are not added to the lookup.\n\t    var newCommentIds = Object.keys(this.isNew);\n\t    var hasNewComments = {};\n\t    for (var i = 0, l = newCommentIds.length; i < l; i++) {\n\t      var parent = this.parents[newCommentIds[i]];\n\t      while (parent) {\n\t        // Stop when we hit one we've seen before\n\t        if (hasNewComments[parent]) {\n\t          break;\n\t        }\n\t        hasNewComments[parent] = true;\n\t        parent = this.parents[parent];\n\t      }\n\t    }\n\t\n\t    // Walk the tree of comments one level at a time, only walking children to\n\t    // comments we know have new comment descendants, to find subtrees which\n\t    // don't have new comments.\n\t    // Other comments are marked for collapsing unless they are themselves a\n\t    // new comment (in which case all their replies must be new too).\n\t    var shouldCollapse = {};\n\t    var commentIds = this.children[this.itemId];\n\t    while (commentIds.length) {\n\t      var nextCommentIds = [];\n\t      for (i = 0, l = commentIds.length; i < l; i++) {\n\t        var commentId = commentIds[i];\n\t        if (!hasNewComments[commentId]) {\n\t          if (!this.isNew[commentId]) {\n\t            shouldCollapse[commentId] = true;\n\t          }\n\t        } else {\n\t          var childCommentIds = this.children[commentId];\n\t          if (childCommentIds.length) {\n\t            nextCommentIds.push.apply(nextCommentIds, childCommentIds);\n\t          }\n\t        }\n\t      }\n\t      commentIds = nextCommentIds;\n\t    }\n\t\n\t    this.isCollapsed = shouldCollapse;\n\t    this.onCommentsChanged({ type: 'collapse' });\n\t  },\n\t\n\t  /**\n\t   * Merk the thread as read.\n\t   */\n\t  markAsRead: function markAsRead() {\n\t    this.lastVisit = Date.now();\n\t    this.newCommentCount = 0;\n\t    this.prevMaxCommentId = this.maxCommentId;\n\t    this.isNew = {};\n\t    this._storeState();\n\t  },\n\t\n\t  /**\n\t   * Persist comment thread state and perform any necessary internal cleanup.\n\t   */\n\t  dispose: function dispose() {\n\t    // Cancel debounced callbacks in case any are pending\n\t    this.numberOfCommentsChanged.cancel();\n\t    this._storeState();\n\t  }\n\t});\n\t\n\tmodule.exports = StoryCommentThreadStore;\n\n/***/ },\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\tvar ReactFireMixin = __webpack_require__(24);\n\t\n\tvar CommentThreadStore = __webpack_require__(60);\n\tvar HNService = __webpack_require__(12);\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar CommentMixin = __webpack_require__(58);\n\t\n\tvar cx = __webpack_require__(32);\n\t\n\t/**\n\t * A comment in a thread.\n\t */\n\tvar Comment = React.createClass({\n\t  displayName: 'Comment',\n\t\n\t  mixins: [CommentMixin, ReactFireMixin],\n\t\n\t  propTypes: {\n\t    id: React.PropTypes.number.isRequired,\n\t    level: React.PropTypes.number.isRequired,\n\t    loadingSpinner: React.PropTypes.bool,\n\t    threadStore: React.PropTypes.instanceOf(CommentThreadStore).isRequired\n\t  },\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      loadingSpinner: false\n\t    };\n\t  },\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      comment: {}\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindFirebaseRef();\n\t  },\n\t\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    this.clearDelayTimeout();\n\t  },\n\t\n\t  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t    // Huge, fast-growing threads like https://news.ycombinator.com/item?id=9784470\n\t    // seem to break the API - some comments are coming back from Firebase as null.\n\t    if (!this.state.comment) {\n\t      this.props.threadStore.adjustExpectedComments(-1);\n\t      return;\n\t    }\n\t\n\t    // On !prevState.comment: a comment which was initially null - see\n\t    // above - may eventually load when the API catches up.\n\t    if (!prevState.comment || !prevState.comment.id) {\n\t      // Register a newly-loaded comment with the thread store\n\t      if (this.state.comment.id) {\n\t        // If the comment was delayed, cancel any pending timeout\n\t        if (prevState.comment && prevState.comment.delayed) {\n\t          this.clearDelayTimeout();\n\t        }\n\t        this.props.threadStore.commentAdded(this.state.comment);\n\t      }\n\t      if (prevState.comment && !prevState.comment.delayed && this.state.comment.delayed) {\n\t        this.props.threadStore.commentDelayed(this.props.id);\n\t      }\n\t    }\n\t    // The comment was already loaded, look for changes to it\n\t    else {\n\t        if (!prevState.comment.deleted && this.state.comment.deleted) {\n\t          this.props.threadStore.commentDeleted(this.state.comment);\n\t        }\n\t        if (!prevState.comment.dead && this.state.comment.dead) {\n\t          this.props.threadStore.commentDied(this.state.comment);\n\t        }\n\t        // If the comment has been updated and the initial set of comments is\n\t        // still loading, the number of expected comments might need to be\n\t        // adjusted.\n\t        else if (prevState.comment !== this.state.comment && this.props.threadStore.loading) {\n\t            var kids = this.state.comment.kids ? this.state.comment.kids.length : 0;\n\t            var prevKids = prevState.comment.kids ? prevState.comment.kids.length : 0;\n\t            this.props.threadStore.adjustExpectedComments(kids - prevKids);\n\t          }\n\t      }\n\t  },\n\t\n\t  bindFirebaseRef: function bindFirebaseRef() {\n\t    this.bindAsObject(HNService.itemRef(this.props.id), 'comment', this.handleFirebaseRefCancelled);\n\t    if (this.timeout) {\n\t      this.timeout = null;\n\t    }\n\t  },\n\t\n\t  /**\n\t   * This is usually caused by a permissions error loading the comment due to\n\t   * its author using the delay setting (note: this is conjecture), which is\n\t   * measured in minutes - try again in 30 seconds.\n\t   */\n\t  handleFirebaseRefCancelled: function handleFirebaseRefCancelled(e) {\n\t    if (false) {\n\t      console.error('Firebase ref for comment ' + this.props.id + ' was cancelled: ' + e.message);\n\t    }\n\t    this.unbind('comment');\n\t    this.timeout = setTimeout(this.bindFirebaseRef, 30000);\n\t    if (this.state.comment && !this.state.comment.delayed) {\n\t      this.state.comment.delayed = true;\n\t      this.forceUpdate();\n\t    }\n\t  },\n\t\n\t  clearDelayTimeout: function clearDelayTimeout() {\n\t    if (this.timeout) {\n\t      clearTimeout(this.timeout);\n\t      this.timeout = null;\n\t    }\n\t  },\n\t\n\t  toggleCollapse: function toggleCollapse(e) {\n\t    e.preventDefault();\n\t    this.props.threadStore.toggleCollapse(this.state.comment.id);\n\t  },\n\t\n\t  render: function render() {\n\t    var comment = this.state.comment;\n\t    var props = this.props;\n\t    if (!comment) {\n\t      return this.renderError(comment, {\n\t        id: this.props.id,\n\t        className: 'Comment Comment--error Comment--level' + props.level\n\t      });\n\t    }\n\t    // Render a placeholder while we're waiting for the comment to load\n\t    if (!comment.id) {\n\t      return this.renderCommentLoading(comment);\n\t    }\n\t    // Don't show dead coments or their children, when configured\n\t    if (comment.dead && !SettingsStore.showDead) {\n\t      return null;\n\t    }\n\t    // Render a link to HN for deleted comments if they're being displayed\n\t    if (comment.deleted) {\n\t      if (!SettingsStore.showDeleted) {\n\t        return null;\n\t      }\n\t      return this.renderCommentDeleted(comment, {\n\t        className: 'Comment Comment--deleted Comment--level' + props.level\n\t      });\n\t    }\n\t\n\t    var isNew = props.threadStore.isNew[comment.id];\n\t    var collapsed = !!props.threadStore.isCollapsed[comment.id];\n\t    var childCounts = collapsed && props.threadStore.getChildCounts(comment);\n\t    if (collapsed && isNew) {\n\t      childCounts.newComments = 0;\n\t    }\n\t    var className = cx('Comment Comment--level' + props.level, {\n\t      'Comment--collapsed': collapsed,\n\t      'Comment--dead': comment.dead,\n\t      'Comment--new': isNew\n\t    });\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        this.renderCommentMeta(comment, {\n\t          collapsible: true,\n\t          collapsed: collapsed,\n\t          link: true,\n\t          childCounts: childCounts\n\t        }),\n\t        this.renderCommentText(comment, { replyLink: true })\n\t      ),\n\t      comment.kids && React.createElement(\n\t        'div',\n\t        { className: 'Comment__kids' },\n\t        comment.kids.map(function (id) {\n\t          return React.createElement(Comment, { key: id, id: id,\n\t            level: props.level + 1,\n\t            loadingSpinner: props.loadingSpinner,\n\t            threadStore: props.threadStore\n\t          });\n\t        })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Comment;\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar _require = __webpack_require__(26);\n\t\n\tvar Link = _require.Link;\n\t\n\tvar Paginator = React.createClass({\n\t  displayName: 'Paginator',\n\t\n\t  _onClick: function _onClick(e) {\n\t    setTimeout(function () {\n\t      window.scrollTo(0, 0);\n\t    }, 0);\n\t  },\n\t\n\t  render: function render() {\n\t    if (this.props.page == 1 && !this.props.hasNext) {\n\t      return null;\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Paginator' },\n\t      this.props.page > 1 && React.createElement(\n\t        'span',\n\t        { className: 'Paginator__prev' },\n\t        React.createElement(\n\t          Link,\n\t          { to: '/' + this.props.route, query: { page: this.props.page - 1 }, onClick: this._onClick },\n\t          'Prev'\n\t        )\n\t      ),\n\t      this.props.page > 1 && this.props.hasNext && ' | ',\n\t      this.props.hasNext && React.createElement(\n\t        'span',\n\t        { className: 'Paginator__next' },\n\t        React.createElement(\n\t          Link,\n\t          { to: '/' + this.props.route, query: { page: this.props.page + 1 }, onClick: this._onClick },\n\t          'More'\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Paginator;\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar _require = __webpack_require__(26);\n\t\n\tvar Link = _require.Link;\n\t\n\tvar SettingsStore = __webpack_require__(7);\n\tvar cx = __webpack_require__(32);\n\t\n\t/**\n\t * Reusable logic for displaying an item in a list.\n\t * Must be used in conjunction with ItemMixin for its rendering methods.\n\t */\n\tvar ListItemMixin = {\n\t  getNewCommentCount: function getNewCommentCount(item, threadState) {\n\t    if (threadState.lastVisit === null) {\n\t      return 0;\n\t    }\n\t    return item.descendants - threadState.commentCount;\n\t  },\n\t\n\t  renderListItem: function renderListItem(item, threadState) {\n\t    if (item.deleted) {\n\t      return null;\n\t    }\n\t    var newCommentCount = this.getNewCommentCount(item, threadState);\n\t    return React.createElement(\n\t      'li',\n\t      { className: cx('ListItem', { 'ListItem--dead': item.dead }), style: { marginBottom: SettingsStore.listSpacing } },\n\t      this.renderItemTitle(item),\n\t      this.renderItemMeta(item, newCommentCount > 0 && React.createElement(\n\t        'span',\n\t        { className: 'ListItem__newcomments' },\n\t        ' ',\n\t        '(',\n\t        React.createElement(\n\t          Link,\n\t          { to: '/' + item.type + '/' + item.id },\n\t          newCommentCount,\n\t          ' new'\n\t        ),\n\t        ')'\n\t      ))\n\t    );\n\t  }\n\t};\n\t\n\tmodule.exports = ListItemMixin;\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar PageNumberMixin = {\n\t  getPageNumber: function getPageNumber(page) {\n\t    if (typeof page == 'undefined') {\n\t      page = this.props.location.query.page;\n\t    }\n\t    return page && /^\\d+$/.test(page) ? Math.max(1, Number(page)) : 1;\n\t  }\n\t};\n\t\n\tmodule.exports = PageNumberMixin;\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {'use strict';\n\t\n\tvar HNService = __webpack_require__(12);\n\t\n\tvar StoryStore = __webpack_require__(44);\n\tvar UpdatesStore = __webpack_require__(45);\n\t\n\tvar commentParentLookup = {};\n\tvar titleCache = {};\n\t\n\tfunction fetchCommentParent(comment, cb, result) {\n\t  var commentId = comment.id;\n\t  var parentId = comment.parent;\n\t\n\t  while (commentParentLookup[parentId] || titleCache[parentId]) {\n\t    // We just saved ourselves an item fetch\n\t    result.itemCount++;\n\t    result.cacheHits++;\n\t\n\t    // The parent is a known non-comment\n\t    if (titleCache[parentId]) {\n\t      if (result.itemCount === 1) {\n\t        result.parent = titleCache[parentId];\n\t      }\n\t      result.op = titleCache[parentId];\n\t      cb(result);\n\t      return;\n\t    }\n\t\n\t    // The parent is a known comment\n\t    if (commentParentLookup[parentId]) {\n\t      if (result.itemCount === 1) {\n\t        result.parent = { id: parentId, type: 'comment' };\n\t      }\n\t      // Set the parent comment's ids up for the next iteration\n\t      commentId = parentId;\n\t      parentId = commentParentLookup[parentId];\n\t    }\n\t  }\n\t\n\t  // The parent of the current comment isn't known, so we'll have to fetch it\n\t  ItemStore.getItem(parentId, function (parent) {\n\t    result.itemCount++;\n\t    // Add the current comment's parent to the lookup for next time\n\t    commentParentLookup[commentId] = parentId;\n\t    if (parent.type === 'comment') {\n\t      commentParentLookup[parent.id] = parent.parent;\n\t    }\n\t    processCommentParent(parent, cb, result);\n\t  }, result);\n\t}\n\t\n\tfunction processCommentParent(item, cb, result) {\n\t  if (result.itemCount === 1) {\n\t    result.parent = item;\n\t  }\n\t  if (item.type !== 'comment') {\n\t    result.op = item;\n\t    titleCache[item.id] = {\n\t      id: item.id,\n\t      type: item.type,\n\t      title: item.title\n\t    };\n\t    cb(result);\n\t  } else {\n\t    fetchCommentParent(item, cb, result);\n\t  }\n\t}\n\t\n\tvar ItemStore = {\n\t  getItem: function getItem(id, cb, result) {\n\t    var cachedItem = this.getCachedItem(id);\n\t    if (cachedItem) {\n\t      if (result) {\n\t        result.cacheHits++;\n\t      }\n\t      setImmediate(cb, cachedItem);\n\t    } else {\n\t      HNService.fetchItem(id, cb);\n\t    }\n\t  },\n\t\n\t  getCachedItem: function getCachedItem(id) {\n\t    return StoryStore.getItem(id) || UpdatesStore.getItem(id) || null;\n\t  },\n\t\n\t  getCachedStory: function getCachedStory(id) {\n\t    return StoryStore.getItem(id) || UpdatesStore.getStory(id) || null;\n\t  },\n\t\n\t  fetchCommentAncestors: function fetchCommentAncestors(comment, cb) {\n\t    var startTime = Date.now();\n\t    var result = { itemCount: 0, cacheHits: 0 };\n\t    fetchCommentParent(comment, function () {\n\t      result.timeTaken = Date.now() - startTime;\n\t      setImmediate(cb, result);\n\t    }, result);\n\t  }\n\t};\n\t\n\tmodule.exports = ItemStore;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57).setImmediate))\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction pageCalc(pageNum, pageSize, numItems) {\n\t  var startIndex = (pageNum - 1) * pageSize;\n\t  var endIndex = Math.min(numItems, startIndex + pageSize);\n\t  var hasNext = endIndex < numItems - 1;\n\t  return { pageNum: pageNum, startIndex: startIndex, endIndex: endIndex, hasNext: hasNext };\n\t}\n\t\n\tmodule.exports = pageCalc;\n\n/***/ },\n/* 92 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  get: function get(key, defaultValue) {\n\t    var value = window.localStorage[key];\n\t    return typeof value != 'undefined' ? value : defaultValue;\n\t  },\n\t  set: function set(key, value) {\n\t    window.localStorage[key] = value;\n\t  }\n\t};\n\n/***/ },\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */,\n/* 114 */,\n/* 115 */,\n/* 116 */,\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */,\n/* 123 */,\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar CommentMixin = __webpack_require__(58);\n\t\n\tvar cx = __webpack_require__(32);\n\t\n\t/**\n\t * Displays a standalone comment passed as a prop.\n\t */\n\tvar DisplayComment = React.createClass({\n\t  displayName: 'DisplayComment',\n\t\n\t  mixins: [CommentMixin],\n\t\n\t  propTypes: {\n\t    comment: React.PropTypes.object.isRequired\n\t  },\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      op: {},\n\t      parent: { type: 'comment' }\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.fetchAncestors(this.props.comment);\n\t  },\n\t\n\t  render: function render() {\n\t    if (this.props.comment.deleted) {\n\t      return null;\n\t    }\n\t    if (this.props.comment.dead && !SettingsStore.showDead) {\n\t      return null;\n\t    }\n\t\n\t    var comment = this.props.comment;\n\t    var className = cx('Comment Comment--level0', {\n\t      'Comment--dead': comment.dead\n\t    });\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        this.renderCommentMeta(comment, {\n\t          link: true,\n\t          parent: !!this.state.parent.id && !!this.state.op.id && comment.parent != this.state.op.id,\n\t          op: !!this.state.op.id\n\t        }),\n\t        this.renderCommentText(comment, { replyLink: false })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = DisplayComment;\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar StoryCommentThreadStore = __webpack_require__(61);\n\t\n\tvar ItemMixin = __webpack_require__(59);\n\tvar ListItemMixin = __webpack_require__(88);\n\t\n\t/**\n\t * Display story title and metadata as a list item.\n\t * The story to display will be passed as a prop.\n\t */\n\tvar DisplayListItem = React.createClass({\n\t  displayName: 'DisplayListItem',\n\t\n\t  mixins: [ItemMixin, ListItemMixin],\n\t\n\t  propTypes: {\n\t    item: React.PropTypes.object.isRequired\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.threadState = StoryCommentThreadStore.loadState(this.props.item.id);\n\t  },\n\t\n\t  render: function render() {\n\t    return this.renderListItem(this.props.item, this.threadState);\n\t  }\n\t});\n\t\n\tmodule.exports = DisplayListItem;\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\tvar ReactFireMixin = __webpack_require__(24);\n\tvar TimeAgo = __webpack_require__(37);\n\t\n\tvar HNService = __webpack_require__(12);\n\tvar StoryCommentThreadStore = __webpack_require__(61);\n\tvar ItemStore = __webpack_require__(90);\n\t\n\tvar Comment = __webpack_require__(86);\n\tvar PollOption = __webpack_require__(128);\n\tvar Spinner = __webpack_require__(20);\n\tvar ItemMixin = __webpack_require__(59);\n\t\n\tvar cx = __webpack_require__(32);\n\tvar setTitle = __webpack_require__(34);\n\t\n\tfunction timeUnitsAgo(value, unit, suffix) {\n\t  if (value == 1) {\n\t    return unit;\n\t  }\n\t  return value + ' ' + unit + 's';\n\t}\n\t\n\tvar Item = React.createClass({\n\t  displayName: 'Item',\n\t\n\t  mixins: [ItemMixin, ReactFireMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      item: ItemStore.getCachedStory(Number(this.props.params.id)) || {}\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindAsObject(HNService.itemRef(this.props.params.id), 'item');\n\t    if (this.state.item.id) {\n\t      this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, { cached: true });\n\t      setTitle(this.state.item.title);\n\t    }\n\t    window.addEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    if (this.threadStore) {\n\t      this.threadStore.dispose();\n\t    }\n\t    window.removeEventListener('beforeunload', this.handleBeforeUnload);\n\t  },\n\t\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.params.id != nextProps.params.id) {\n\t      // Tear it down...\n\t      this.threadStore.dispose();\n\t      this.threadStore = null;\n\t      this.unbind('item');\n\t      // ...and set it up again\n\t      var item = ItemStore.getCachedStory(Number(nextProps.params.id));\n\t      if (item) {\n\t        this.threadStore = new StoryCommentThreadStore(item, this.handleCommentsChanged, { cached: true });\n\t        setTitle(item.title);\n\t      }\n\t      this.bindAsObject(HNService.itemRef(nextProps.params.id), 'item');\n\t      this.setState({ item: item || {} });\n\t    }\n\t  },\n\t\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    // Update the title when the item has loaded.\n\t    if (!this.state.item.id && nextState.item.id) {\n\t      setTitle(nextState.item.title);\n\t    }\n\t  },\n\t\n\t  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t    // If the state item id changed, an initial or new item must have loaded\n\t    if (prevState.item.id != this.state.item.id) {\n\t      if (!this.threadStore || this.threadStore.itemId != this.state.item.id) {\n\t        this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, { cached: false });\n\t        setTitle(this.state.item.title);\n\t        this.forceUpdate();\n\t      }\n\t    } else if (prevState.item !== this.state.item) {\n\t      // If the item has been updated from Firebase and the initial set\n\t      // of comments is still loading, the number of expected comments might\n\t      // need to be adjusted.\n\t      // This triggers a check for thread load completion, completing it\n\t      // immediately if a cached item had 0 kids and the latest version from\n\t      // Firebase also has 0 kids.\n\t      if (this.threadStore.loading) {\n\t        var kids = this.state.item.kids ? this.state.item.kids.length : 0;\n\t        var prevKids = prevState.item.kids ? prevState.item.kids.length : 0;\n\t        var kidDiff = kids - prevKids;\n\t        if (kidDiff !== 0) {\n\t          this.threadStore.adjustExpectedComments(kidDiff);\n\t        }\n\t      }\n\t      this.threadStore.itemUpdated(this.state.item);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Ensure the last visit time and comment details get stored for this item if\n\t   * the user refreshes or otherwise navigates off the page.\n\t   */\n\t  handleBeforeUnload: function handleBeforeUnload() {\n\t    if (this.threadStore) {\n\t      this.threadStore.dispose();\n\t    }\n\t  },\n\t\n\t  handleCommentsChanged: function handleCommentsChanged(payload) {\n\t    this.forceUpdate();\n\t  },\n\t\n\t  autoCollapse: function autoCollapse(e) {\n\t    e.preventDefault();\n\t    this.threadStore.collapseThreadsWithoutNewComments();\n\t  },\n\t\n\t  markAsRead: function markAsRead(e) {\n\t    e.preventDefault();\n\t    this.threadStore.markAsRead();\n\t    this.forceUpdate();\n\t  },\n\t\n\t  render: function render() {\n\t    var state = this.state;\n\t    var item = state.item;\n\t    var threadStore = this.threadStore;\n\t    if (!item.id || !threadStore) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Item Item--loading' },\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: cx('Item', { 'Item--dead': item.dead }) },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Item__content' },\n\t        this.renderItemTitle(item),\n\t        this.renderItemMeta(item, threadStore.lastVisit !== null && threadStore.newCommentCount > 0 && React.createElement(\n\t          'span',\n\t          null,\n\t          ' ',\n\t          '(',\n\t          React.createElement(\n\t            'em',\n\t            null,\n\t            threadStore.newCommentCount,\n\t            ' new'\n\t          ),\n\t          ' in the last ',\n\t          React.createElement(TimeAgo, { date: threadStore.lastVisit, formatter: timeUnitsAgo }),\n\t          ') | ',\n\t          React.createElement(\n\t            'span',\n\t            { className: 'control', tabIndex: '0', onClick: this.autoCollapse, onKeyPress: this.autoCollapse, title: 'Collapse threads without new comments' },\n\t            'auto collapse'\n\t          ),\n\t          ' | ',\n\t          React.createElement(\n\t            'span',\n\t            { className: 'control', tabIndex: '0', onClick: this.markAsRead, onKeyPress: this.markAsRead },\n\t            'mark as read'\n\t          )\n\t        )),\n\t        item.text && React.createElement(\n\t          'div',\n\t          { className: 'Item__text' },\n\t          React.createElement('div', { dangerouslySetInnerHTML: { __html: item.text } })\n\t        ),\n\t        item.type == 'poll' && React.createElement(\n\t          'div',\n\t          { className: 'Item__poll' },\n\t          item.parts.map(function (id) {\n\t            return React.createElement(PollOption, { key: id, id: id });\n\t          })\n\t        )\n\t      ),\n\t      item.kids && React.createElement(\n\t        'div',\n\t        { className: 'Item__kids' },\n\t        item.kids.map(function (id, index) {\n\t          return React.createElement(Comment, { key: id, id: id, level: 0,\n\t            loadingSpinner: index === 0,\n\t            threadStore: threadStore\n\t          });\n\t        })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Item;\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\tvar ReactFireMixin = __webpack_require__(24);\n\t\n\tvar CommentThreadStore = __webpack_require__(60);\n\tvar HNService = __webpack_require__(12);\n\tvar SettingsStore = __webpack_require__(7);\n\tvar UpdatesStore = __webpack_require__(45);\n\t\n\tvar Comment = __webpack_require__(86);\n\tvar CommentMixin = __webpack_require__(58);\n\t\n\tvar cx = __webpack_require__(32);\n\tvar _setTitle = __webpack_require__(34);\n\t\n\tvar PermalinkedComment = React.createClass({\n\t  displayName: 'PermalinkedComment',\n\t\n\t  mixins: [CommentMixin, ReactFireMixin],\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      level: 0,\n\t      loadingSpinner: true\n\t    };\n\t  },\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      comment: UpdatesStore.getComment(this.props.params.id) || {},\n\t      parent: { type: 'comment' },\n\t      op: {}\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindAsObject(HNService.itemRef(this.props.params.id), 'comment');\n\t    if (this.state.comment.id) {\n\t      this.commentLoaded(this.state.comment);\n\t    }\n\t  },\n\t\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (nextProps.params.id != this.props.params.id) {\n\t      var comment = UpdatesStore.getComment(nextProps.params.id);\n\t      if (comment) {\n\t        this.commentLoaded(comment);\n\t        this.setState({ comment: comment });\n\t      }\n\t      this.unbind('comment');\n\t      this.bindAsObject(HNService.itemRef(nextProps.params.id), 'comment');\n\t    }\n\t  },\n\t\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    if (!nextState.comment) {\n\t      return;\n\t    }\n\t\n\t    if (this.state.comment.id != nextState.comment.id) {\n\t      if (!nextState.comment.deleted) {\n\t        // Redirect to the appropriate route if a Comment \"parent\" link had a\n\t        // non-comment item id.\n\t        if (nextState.comment.type != 'comment') {\n\t          this.context.router.replaceWith(nextState.comment.type, { id: nextState.comment.id });\n\t          return;\n\t        }\n\t      }\n\t      if (!this.threadStore || this.threadStore.itemId != nextState.comment.id) {\n\t        this.commentLoaded(nextState.comment);\n\t      }\n\t    }\n\t  },\n\t\n\t  commentLoaded: function commentLoaded(comment) {\n\t    this.setTitle(comment);\n\t    if (!comment.deleted) {\n\t      this.threadStore = new CommentThreadStore(comment, this.handleCommentsChanged);\n\t      this.fetchAncestors(comment);\n\t    }\n\t  },\n\t\n\t  setTitle: function setTitle(comment) {\n\t    if (comment.deleted) {\n\t      return _setTitle('Deleted comment');\n\t    }\n\t    var title = 'Comment by ' + comment.by;\n\t    if (this.state.op.id) {\n\t      title += ' | ' + this.state.op.title;\n\t    }\n\t    _setTitle(title);\n\t  },\n\t\n\t  handleCommentsChanged: function handleCommentsChanged(payload) {\n\t    // We're only interested in re-rendering to update collapsed display\n\t    if (payload.type == 'collapse') {\n\t      this.forceUpdate();\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    var comment = this.state.comment;\n\t    if (!comment) {\n\t      return this.renderError(comment, {\n\t        id: this.props.params.id,\n\t        className: 'Comment Comment--level0 Comment--error'\n\t      });\n\t    }\n\t    // Render a placeholder while we're waiting for the comment to load\n\t    if (!comment.id) {\n\t      return this.renderCommentLoading(comment);\n\t    }\n\t    // Render a link to HN for deleted comments\n\t    if (comment.deleted) {\n\t      return this.renderCommentDeleted(comment, {\n\t        className: 'Comment Comment--level0 Comment--deleted'\n\t      });\n\t    }\n\t    // XXX Don't render anything if we're replacing the route after loading a non-comment\n\t    if (comment.type != 'comment') {\n\t      return null;\n\t    }\n\t\n\t    var className = cx('PermalinkedComment Comment Comment--level0', { 'Comment--dead': comment.dead });\n\t    var threadStore = this.threadStore;\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: className },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'Comment__content' },\n\t        this.renderCommentMeta(comment, {\n\t          parent: !!this.state.parent.id && !!this.state.op.id && comment.parent != this.state.op.id,\n\t          op: !!this.state.op.id\n\t        }),\n\t        (!comment.dead || SettingsStore.showDead) && this.renderCommentText(comment, { replyLink: true })\n\t      ),\n\t      comment.kids && React.createElement(\n\t        'div',\n\t        { className: 'Comment__kids' },\n\t        comment.kids.map(function (id, index) {\n\t          return React.createElement(Comment, { key: id, id: id,\n\t            level: 0,\n\t            loadingSpinner: index === 0,\n\t            threadStore: threadStore\n\t          });\n\t        })\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = PermalinkedComment;\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\tvar ReactFireMixin = __webpack_require__(24);\n\t\n\tvar HNService = __webpack_require__(12);\n\t\n\tvar Spinner = __webpack_require__(20);\n\t\n\tvar pluralise = __webpack_require__(47);\n\t\n\tvar PollOption = React.createClass({\n\t  displayName: 'PollOption',\n\t\n\t  mixins: [ReactFireMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return { pollopt: {} };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindAsObject(HNService.itemRef(this.props.id), 'pollopt');\n\t  },\n\t\n\t  render: function render() {\n\t    var pollopt = this.state.pollopt;\n\t    if (!pollopt.id) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'PollOption PollOption--loading' },\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'PollOption' },\n\t      React.createElement(\n\t        'div',\n\t        { className: 'PollOption__text' },\n\t        pollopt.text\n\t      ),\n\t      React.createElement(\n\t        'div',\n\t        { className: 'PollOption__score' },\n\t        pollopt.score,\n\t        ' point',\n\t        pluralise(pollopt.score)\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = PollOption;\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar Settings = React.createClass({\n\t  displayName: 'Settings',\n\t\n\t  componentDidMount: function componentDidMount() {\n\t    this.refs.container.getDOMNode().focus();\n\t  },\n\t\n\t  onChange: function onChange(e) {\n\t    var el = e.target;\n\t    if (el.type === 'checkbox') {\n\t      SettingsStore[el.name] = el.checked;\n\t    } else if (el.type === 'number' && el.value) {\n\t      SettingsStore[el.name] = el.value;\n\t    }\n\t    this.forceUpdate();\n\t    SettingsStore.save();\n\t  },\n\t\n\t  onClick: function onClick(e) {\n\t    e.stopPropagation();\n\t  },\n\t\n\t  render: function render() {\n\t    return React.createElement(\n\t      'div',\n\t      { ref: 'container', className: 'Settings', tabIndex: '-1', onClick: this.onClick },\n\t      React.createElement(\n\t        'form',\n\t        { onChange: this.onChange },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'autoCollapse' },\n\t            React.createElement('input', { type: 'checkbox', name: 'autoCollapse', id: 'autoCollapse', checked: SettingsStore.autoCollapse }),\n\t            ' auto collapse'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Automatically collapse comment threads without new comments on page load.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'replyLinks' },\n\t            React.createElement('input', { type: 'checkbox', name: 'replyLinks', id: 'replyLinks', checked: SettingsStore.replyLinks }),\n\t            ' show reply links'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Show \"reply\" links to Hacker News'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'showDead' },\n\t            React.createElement('input', { type: 'checkbox', name: 'showDead', id: 'showDead', checked: SettingsStore.showDead }),\n\t            ' show dead'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Show items flagged as dead.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting Settings__setting--checkbox' },\n\t          React.createElement(\n\t            'label',\n\t            { htmlFor: 'showDeleted' },\n\t            React.createElement('input', { type: 'checkbox', name: 'showDeleted', id: 'showDeleted', checked: SettingsStore.showDeleted }),\n\t            ' show deleted'\n\t          ),\n\t          React.createElement(\n\t            'p',\n\t            null,\n\t            'Show comments flagged as deleted in threads.'\n\t          )\n\t        ),\n\t        React.createElement(\n\t          'div',\n\t          { className: 'Settings__setting' },\n\t          React.createElement(\n\t            'table',\n\t            null,\n\t            React.createElement(\n\t              'tbody',\n\t              null,\n\t              React.createElement(\n\t                'tr',\n\t                null,\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement(\n\t                    'label',\n\t                    { htmlFor: 'titleFontSize' },\n\t                    'title font size:'\n\t                  )\n\t                ),\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement('input', { type: 'number', min: '13.333', step: '1', name: 'titleFontSize', id: 'titleFontSize', value: SettingsStore.titleFontSize })\n\t                )\n\t              ),\n\t              React.createElement(\n\t                'tr',\n\t                null,\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement(\n\t                    'label',\n\t                    { htmlFor: 'listSpacing' },\n\t                    'list spacing:'\n\t                  )\n\t                ),\n\t                React.createElement(\n\t                  'td',\n\t                  null,\n\t                  React.createElement('input', { type: 'number', min: '0', name: 'listSpacing', id: 'listSpacing', value: SettingsStore.listSpacing })\n\t                )\n\t              )\n\t            )\n\t          )\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = Settings;\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar StoryStore = __webpack_require__(44);\n\t\n\tvar PageNumberMixin = __webpack_require__(89);\n\tvar Paginator = __webpack_require__(87);\n\tvar Spinner = __webpack_require__(20);\n\tvar StoryListItem = __webpack_require__(131);\n\tvar SettingsStore = __webpack_require__(7);\n\t\n\tvar _require = __webpack_require__(46);\n\t\n\tvar ITEMS_PER_PAGE = _require.ITEMS_PER_PAGE;\n\t\n\tvar pageCalc = __webpack_require__(91);\n\tvar setTitle = __webpack_require__(34);\n\t\n\tvar Stories = React.createClass({\n\t  displayName: 'Stories',\n\t\n\t  mixins: [PageNumberMixin],\n\t\n\t  propTypes: {\n\t    // The number of stories which may be paginated through\n\t    limit: React.PropTypes.number.isRequired,\n\t    // The route name being used\n\t    route: React.PropTypes.string.isRequired,\n\t    // The type of stories to be displayed\n\t    type: React.PropTypes.string.isRequired,\n\t\n\t    // Page title associated with the stories being displayed\n\t    title: React.PropTypes.string\n\t  },\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      ids: [],\n\t      limit: this.props.limit,\n\t      stories: []\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    setTitle(this.props.title);\n\t    this.store = new StoryStore(this.props.type);\n\t    this.store.addListener('update', this.handleUpdate);\n\t    this.store.start();\n\t    this.setState(this.store.getState());\n\t  },\n\t\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    this.store.removeListener('update', this.handleUpdate);\n\t    this.store.stop();\n\t    this.store = null;\n\t  },\n\t\n\t  handleUpdate: function handleUpdate(update) {\n\t    if (!this.isMounted()) {\n\t      if (false) {\n\t        console.warn('Skipping update as the ' + this.props.type + ' Stories component is no longer mounted.');\n\t      }\n\t      return;\n\t    }\n\t    update.limit = update.ids.length;\n\t    this.setState(update);\n\t  },\n\t\n\t  render: function render() {\n\t    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, this.state.limit);\n\t\n\t    // Display a list of placeholder items while we're waiting for the initial\n\t    // list of story ids to load from Firebase.\n\t    if (this.state.stories.length === 0 && this.state.ids.length === 0) {\n\t      var dummyItems = [];\n\t      for (var i = page.startIndex; i < page.endIndex; i++) {\n\t        dummyItems.push(React.createElement(\n\t          'li',\n\t          { key: i, className: 'ListItem ListItem--loading', style: { marginBottom: SettingsStore.listSpacing } },\n\t          React.createElement(Spinner, null)\n\t        ));\n\t      }\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Items Items--loading' },\n\t        React.createElement(\n\t          'ol',\n\t          { className: 'Items__list', start: page.startIndex + 1 },\n\t          dummyItems\n\t        ),\n\t        React.createElement(Paginator, { route: this.props.route, page: page.pageNum, hasNext: page.hasNext })\n\t      );\n\t    }\n\t\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'Items' },\n\t      React.createElement(\n\t        'ol',\n\t        { className: 'Items__list', start: page.startIndex + 1 },\n\t        this.renderItems(page.startIndex, page.endIndex)\n\t      ),\n\t      React.createElement(Paginator, { route: this.props.route, page: page.pageNum, hasNext: page.hasNext })\n\t    );\n\t  },\n\t\n\t  renderItems: function renderItems(startIndex, endIndex) {\n\t    var rendered = [];\n\t    for (var i = startIndex; i < endIndex; i++) {\n\t      var item = this.state.stories[i];\n\t      var id = this.state.ids[i];\n\t      if (id) {\n\t        rendered.push(React.createElement(StoryListItem, { key: id, id: id, index: i, cachedItem: item, store: this.store }));\n\t      } else {\n\t        rendered.push(React.createElement(StoryListItem, { cachedItem: item, store: this.store }));\n\t      }\n\t    }\n\t    return rendered;\n\t  }\n\t});\n\t\n\tmodule.exports = Stories;\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\tvar ReactFireMixin = __webpack_require__(24);\n\t\n\tvar StoryCommentThreadStore = __webpack_require__(61);\n\tvar HNService = __webpack_require__(12);\n\tvar SettingsStore = __webpack_require__(7);\n\tvar StoryStore = __webpack_require__(44);\n\t\n\tvar ItemMixin = __webpack_require__(59);\n\tvar ListItemMixin = __webpack_require__(88);\n\tvar Spinner = __webpack_require__(20);\n\t\n\t/**\n\t * Display story title and metadata as as a list item.\n\t * Cached story data may be given as a prop, but this component is also\n\t * responsible for listening to updates to the story and providing the latest\n\t * version for StoryStore's cache.\n\t */\n\tvar StoryListItem = React.createClass({\n\t  displayName: 'StoryListItem',\n\t\n\t  mixins: [ItemMixin, ListItemMixin, ReactFireMixin],\n\t\n\t  propTypes: {\n\t    // The StoryStore handling caching and updates to the stories being displayed\n\t    store: React.PropTypes.instanceOf(StoryStore).isRequired,\n\t\n\t    // The story's id in Hacker News\n\t    id: React.PropTypes.number,\n\t    // A version of the story from the cache, for initial display\n\t    cachedItem: React.PropTypes.object,\n\t    // The current index of the story in the list being displayed\n\t    index: React.PropTypes.number\n\t  },\n\t\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      id: null,\n\t      cachedItem: null,\n\t      index: null\n\t    };\n\t  },\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      item: this.props.cachedItem || {}\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    if (this.props.id != null) {\n\t      this.initLiveItem(this.props);\n\t    } else if (this.props.cachedItem != null) {\n\t      // Display the comment state of the cached item we were given while we're\n\t      // waiting for the live item to load.\n\t      this.threadState = StoryCommentThreadStore.loadState(this.state.item.id);\n\t    }\n\t  },\n\t\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    if (this.props.id != null) {\n\t      this.props.store.removeListener(this.props.id, this.updateThreadState);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Catch the transition from not having an id prop to having one.\n\t   * Scenario: we were waiting for the initial list of story ids to load.\n\t   */\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.id == null && nextProps.id != null) {\n\t      this.initLiveItem(nextProps);\n\t    }\n\t  },\n\t\n\t  /**\n\t   * If the live item has been loaded or updated, update the StoryStore cache\n\t   * with its current index and latest data.\n\t   */\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    if (this.state.item !== nextState.item) {\n\t      if (nextState.item != null) {\n\t        this.props.store.itemUpdated(nextState.item, this.props.index);\n\t      } else {\n\t        if (false) {\n\t          console.warn('Item ' + this.props.id + ' went from ' + JSON.stringify(this.state.item) + ' to ' + nextProps.item);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Initialise listening to updates for the item with the given id and\n\t   * initialise its comment thread state.\n\t   */\n\t  initLiveItem: function initLiveItem(props) {\n\t    // If we were given a cached item to display initially, it will be replaced\n\t    this.bindAsObject(HNService.itemRef(props.id), 'item');\n\t    this.threadState = StoryCommentThreadStore.loadState(props.id);\n\t    this.props.store.addListener(props.id, this.updateThreadState);\n\t  },\n\t\n\t  /**\n\t   * Update thread state in response to a storage event indicating it has been\n\t   * modified.\n\t   */\n\t  updateThreadState: function updateThreadState() {\n\t    this.threadState = StoryCommentThreadStore.loadState(this.props.id);\n\t    this.forceUpdate();\n\t  },\n\t\n\t  render: function render() {\n\t    // Display the loading spinner if we have nothing to show initially\n\t    if (!this.state.item || !this.state.item.id) {\n\t      return React.createElement(\n\t        'li',\n\t        { className: 'ListItem ListItem--loading', style: { marginBottom: SettingsStore.listSpacing } },\n\t        React.createElement(Spinner, null)\n\t      );\n\t    }\n\t\n\t    return this.renderListItem(this.state.item, this.threadState);\n\t  }\n\t});\n\t\n\tmodule.exports = StoryListItem;\n\n/***/ },\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\t\n\tvar SettingsStore = __webpack_require__(7);\n\tvar UpdatesStore = __webpack_require__(45);\n\t\n\tvar DisplayListItem = __webpack_require__(125);\n\tvar DisplayComment = __webpack_require__(124);\n\tvar Paginator = __webpack_require__(87);\n\tvar Spinner = __webpack_require__(20);\n\t\n\tvar PageNumberMixin = __webpack_require__(89);\n\t\n\tvar _require = __webpack_require__(46);\n\t\n\tvar ITEMS_PER_PAGE = _require.ITEMS_PER_PAGE;\n\t\n\tvar pageCalc = __webpack_require__(91);\n\tvar _setTitle = __webpack_require__(34);\n\t\n\tfunction filterDead(item) {\n\t  return !item.dead;\n\t}\n\t\n\tfunction filterUpdates(updates) {\n\t  if (!SettingsStore.showDead) {\n\t    return {\n\t      comments: updates.comments.filter(filterDead),\n\t      stories: updates.stories.filter(filterDead)\n\t    };\n\t  }\n\t  return updates;\n\t}\n\t\n\tvar Updates = React.createClass({\n\t  displayName: 'Updates',\n\t\n\t  mixins: [PageNumberMixin],\n\t\n\t  getInitialState: function getInitialState() {\n\t    return filterUpdates(UpdatesStore.getUpdates());\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.setTitle(this.props.type);\n\t    UpdatesStore.start();\n\t    UpdatesStore.on('updates', this.handleUpdates);\n\t  },\n\t\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    UpdatesStore.off('updates', this.handleUpdates);\n\t    UpdatesStore.stop();\n\t  },\n\t\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.type != nextProps.type) {\n\t      this.setTitle(nextProps.type);\n\t    }\n\t  },\n\t\n\t  setTitle: function setTitle(type) {\n\t    _setTitle('New ' + (type == 'comments' ? 'Comments' : 'Links'));\n\t  },\n\t\n\t  handleUpdates: function handleUpdates(updates) {\n\t    if (!this.isMounted()) {\n\t      if (false) {\n\t        console.warn('Skipping update of ' + this.props.type + ' as the Updates component is not mounted');\n\t      }\n\t      return;\n\t    }\n\t    this.setState(filterUpdates(updates));\n\t  },\n\t\n\t  render: function render() {\n\t    var items = this.props.type == 'comments' ? this.state.comments : this.state.stories;\n\t    if (items.length === 0) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Updates Updates--loading' },\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t\n\t    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, items.length);\n\t\n\t    if (this.props.type == 'comments') {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Updates Comments' },\n\t        items.slice(page.startIndex, page.endIndex).map(function (comment) {\n\t          return React.createElement(DisplayComment, { key: comment.id, id: comment.id, comment: comment });\n\t        }),\n\t        React.createElement(Paginator, { route: 'newcomments', page: page.pageNum, hasNext: page.hasNext })\n\t      );\n\t    } else {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'Updates Items' },\n\t        React.createElement(\n\t          'ol',\n\t          { className: 'Items__list', start: page.startIndex + 1 },\n\t          items.slice(page.startIndex, page.endIndex).map(function (item) {\n\t            return React.createElement(DisplayListItem, { key: item.id, item: item });\n\t          })\n\t        ),\n\t        React.createElement(Paginator, { route: 'newest', page: page.pageNum, hasNext: page.hasNext })\n\t      );\n\t    }\n\t  }\n\t});\n\t\n\tmodule.exports = Updates;\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar React = __webpack_require__(2);\n\tvar ReactFireMixin = __webpack_require__(24);\n\tvar TimeAgo = __webpack_require__(37);\n\t\n\tvar HNService = __webpack_require__(12);\n\t\n\tvar Spinner = __webpack_require__(20);\n\t\n\tvar setTitle = __webpack_require__(34);\n\t\n\t// TODO User submissions\n\t\n\t// TODO User comments\n\t\n\tvar UserProfile = React.createClass({\n\t  displayName: 'UserProfile',\n\t\n\t  mixins: [ReactFireMixin],\n\t  getInitialState: function getInitialState() {\n\t    return { user: {} };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    this.bindAsObject(HNService.userRef(this.props.params.id), 'user');\n\t  },\n\t\n\t  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {\n\t    if (this.state.user.id != nextState.user.id) {\n\t      setTitle('Profile: ' + nextState.user.id);\n\t    }\n\t  },\n\t\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    if (this.props.params.id != nextProps.params.id) {\n\t      this.unbind('user');\n\t      this.bindAsObject(HNService.userRef(nextProps.params.id), 'user');\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    var user = this.state.user;\n\t    if (!user.id) {\n\t      return React.createElement(\n\t        'div',\n\t        { className: 'UserProfile UserProfile--loading' },\n\t        React.createElement(\n\t          'h4',\n\t          null,\n\t          this.props.params.id\n\t        ),\n\t        React.createElement(Spinner, { size: '20' })\n\t      );\n\t    }\n\t    var createdDate = new Date(user.created * 1000);\n\t    return React.createElement(\n\t      'div',\n\t      { className: 'UserProfile' },\n\t      React.createElement(\n\t        'h4',\n\t        null,\n\t        user.id\n\t      ),\n\t      React.createElement(\n\t        'dl',\n\t        null,\n\t        React.createElement(\n\t          'dt',\n\t          null,\n\t          'Created'\n\t        ),\n\t        React.createElement(\n\t          'dd',\n\t          null,\n\t          React.createElement(TimeAgo, { date: createdDate }),\n\t          ' (',\n\t          createdDate.toDateString(),\n\t          ')'\n\t        ),\n\t        React.createElement(\n\t          'dt',\n\t          null,\n\t          'Karma'\n\t        ),\n\t        React.createElement(\n\t          'dd',\n\t          null,\n\t          user.karma\n\t        ),\n\t        React.createElement(\n\t          'dt',\n\t          null,\n\t          'Delay'\n\t        ),\n\t        React.createElement(\n\t          'dd',\n\t          null,\n\t          user.delay\n\t        ),\n\t        user.about && React.createElement(\n\t          'dt',\n\t          null,\n\t          'About'\n\t        ),\n\t        user.about && React.createElement(\n\t          'dd',\n\t          null,\n\t          React.createElement('div', { className: 'UserProfile__about', dangerouslySetInnerHTML: { __html: user.about } })\n\t        )\n\t      )\n\t    );\n\t  }\n\t});\n\t\n\tmodule.exports = UserProfile;\n\n/***/ },\n/* 134 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Based on the implementation of _.debounce() from Underscore.js 1.7.0\n\t * http://underscorejs.org\n\t * (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Distributed under the MIT license.\n\t *\n\t * Returns a function, that, as long as it continues to be invoked, will not\n\t * be triggered. The function will be called after it stops being called for\n\t * N milliseconds. If `immediate` is passed, trigger the function on the\n\t * leading edge, instead of the trailing.\n\t *\n\t * The returned function has a .cancel() function which can be used to prevent\n\t * the debounced functiom being called.\n\t */\n\t\"use strict\";\n\t\n\tfunction cancellableDebounce(func, wait, immediate) {\n\t  var timeout, args, context, timestamp, result;\n\t\n\t  var later = function later() {\n\t    var last = Date.now() - timestamp;\n\t    if (last < wait && last > 0) {\n\t      timeout = setTimeout(later, wait - last);\n\t    } else {\n\t      timeout = null;\n\t      if (!immediate) {\n\t        result = func.apply(context, args);\n\t        if (!timeout) {\n\t          context = args = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  var debounced = function debounced() {\n\t    context = this;\n\t    args = arguments;\n\t    timestamp = Date.now();\n\t    var callNow = immediate && !timeout;\n\t    if (!timeout) {\n\t      timeout = setTimeout(later, wait);\n\t    }\n\t    if (callNow) {\n\t      result = func.apply(context, args);\n\t      context = args = null;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  debounced.cancel = function () {\n\t    if (timeout) {\n\t      clearTimeout(timeout);\n\t    }\n\t  };\n\t\n\t  return debounced;\n\t}\n\t\n\tmodule.exports = cancellableDebounce;\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** app.js\n **/","require('setimmediate')\n\nvar React = require('react')\nvar {IndexRoute, Link, Route, Router} = require('react-router')\n\nvar StoryStore = require('./stores/StoryStore')\nvar UpdatesStore = require('./stores/UpdatesStore')\nvar SettingsStore = require('./stores/SettingsStore')\n\nvar PermalinkedComment = require('./PermalinkedComment')\nvar Item = require('./Item')\nvar Settings = require('./Settings')\nvar Stories = require('./Stories')\nvar Updates = require('./Updates')\nvar UserProfile = require('./UserProfile')\n\nvar App = React.createClass({\n  getInitialState() {\n    return {\n      showSettings: false\n    }\n  },\n\n  componentWillMount() {\n    SettingsStore.load()\n    StoryStore.loadSession()\n    UpdatesStore.loadSession()\n    window.addEventListener('beforeunload', this.handleBeforeUnload)\n  },\n\n  componentWillUnmount() {\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\n  },\n\n  /**\n   * Give stores a chance to persist data to sessionStorage in case this is a\n   * refresh or an external link in the same tab.\n   */\n  handleBeforeUnload() {\n    StoryStore.saveSession()\n    UpdatesStore.saveSession()\n  },\n\n  toggleSettings(e) {\n    e.preventDefault()\n    this.setState({showSettings: !this.state.showSettings})\n  },\n\n  render() {\n    return <div className=\"App\" onClick={this.state.showSettings && this.toggleSettings}>\n      <div className=\"App__wrap\">\n      <div className=\"App__header\">\n        <img src=\"logo.png\" width=\"16\" height=\"16\" alt=\"\" />{' '}\n        <Link to=\"/news\" activeClassName=\"active\" className=\"App__homelink\">React HN</Link>{' '}\n        <Link to=\"/newest\" activeClassName=\"active\">new</Link>{' | '}\n        <Link to=\"/newcomments\" activeClassName=\"active\">comments</Link> {' | '}\n        <Link to=\"/show\" activeClassName=\"active\">show</Link>{' | '}\n        <Link to=\"/ask\" activeClassName=\"active\">ask</Link>{' | '}\n        <Link to=\"/jobs\" activeClassName=\"active\">jobs</Link>\n        <a className=\"App__settings\" tabIndex=\"0\" onClick={this.toggleSettings} onKeyPress={this.toggleSettings}>\n          {this.state.showSettings ? 'hide settings' : 'settings'}\n        </a>\n        {this.state.showSettings && <Settings key=\"settings\"/>}\n      </div>\n      <div className=\"App__content\">\n        {this.props.children}\n      </div>\n      <div className=\"App__footer\">\n        {`react-hn v${__VERSION__} | `}\n        <a href=\"https://github.com/insin/react-hn\">insin/react-hn</a>\n      </div>\n      </div>\n    </div>\n  }\n})\n\nvar NotFound = React.createClass({\n  render() {\n    return <h2>Not found</h2>\n  }\n})\n\nfunction storiesHandler(route, type, limit, title) {\n  return React.createClass({\n    render() {\n      return <Stories {...this.props} key={route} route={route} type={type} limit={limit} title={title}/>\n    }\n  })\n}\n\nfunction updatesHandler(type) {\n  return React.createClass({\n    render() {\n      return <Updates {...this.props} key={type} type={type}/>\n    }\n  })\n}\n\nvar Ask = storiesHandler('ask', 'askstories', 200, 'Ask')\nvar Comments = updatesHandler('comments')\nvar Jobs = storiesHandler('jobs', 'jobstories', 200, 'Jobs')\nvar New = storiesHandler('newest', 'newstories', 500, 'New Links')\nvar Show = storiesHandler('show', 'showstories', 200, 'Show')\nvar Top = storiesHandler('news', 'topstories', 500)\n\nvar routes = <Route path=\"/\" component={App}>\n  <IndexRoute component={Top}/>\n  <Route path=\"news\" component={Top}/>\n  <Route path=\"newest\" component={New}/>\n  <Route path=\"show\" component={Show}/>\n  <Route path=\"ask\" component={Ask}/>\n  <Route path=\"jobs\" component={Jobs}/>\n  <Route path=\"item/:id\" component={Item}/>\n  <Route path=\"job/:id\" component={Item}/>\n  <Route path=\"poll/:id\" component={Item}/>\n  <Route path=\"story/:id\" component={Item}/>\n  <Route path=\"comment/:id\" component={PermalinkedComment}/>\n  <Route path=\"newcomments\" component={Comments}/>\n  <Route path=\"user/:id\" component={UserProfile}/>\n  <Route path=\"*\" component={NotFound}/>\n</Route>\n\nReact.render(<Router routes={routes}/>, document.getElementById('app'))\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/app.jsx\n **/","var extend = require('../utils/extend')\nvar storage = require('../utils/storage')\n\nvar STORAGE_KEY = 'settings'\n\nvar SettingsStore = {\n  autoCollapse: true,\n  replyLinks: true,\n  showDead: false,\n  showDeleted: false,\n  titleFontSize: 18,\n  listSpacing: 16,\n\n  load() {\n    var json = storage.get(STORAGE_KEY)\n    if (json) {\n      extend(this, JSON.parse(json))\n    }\n  },\n\n  save() {\n    storage.set(STORAGE_KEY, JSON.stringify({\n      autoCollapse: this.autoCollapse,\n      replyLinks: this.replyLinks,\n      showDead: this.showDead,\n      showDeleted: this.showDeleted,\n      titleFontSize: this.titleFontSize,\n      listSpacing: this.listSpacing\n    }))\n  }\n}\n\nmodule.exports = SettingsStore\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/stores/SettingsStore.js\n **/","var Firebase = require('firebase')\n\nvar api = new Firebase('https://hacker-news.firebaseio.com/v0')\n\nfunction fetchItem(id, cb) {\n  itemRef(id).once('value', function(snapshot) {\n    cb(snapshot.val())\n  })\n}\n\nfunction fetchItems(ids, cb) {\n  var items = []\n  ids.forEach(function(id) {\n    fetchItem(id, addItem)\n  })\n  function addItem(item) {\n    items.push(item)\n    if (items.length >= ids.length) {\n      cb(items)\n    }\n  }\n}\n\nfunction storiesRef(path) {\n  return api.child(path)\n}\n\nfunction itemRef(id) {\n  return api.child('item/' + id)\n}\n\nfunction userRef(id) {\n  return api.child('user/' + id)\n}\n\nfunction updatesRef() {\n  return api.child('updates/items')\n}\n\nmodule.exports = {\n  fetchItem,\n  fetchItems,\n  storiesRef,\n  itemRef,\n  userRef,\n  updatesRef\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/services/HNService.js\n **/","var React = require('react')\n\n// TODO Implement GIF-based fallback for IE9 and another non-animating browsers\n//      See https://github.com/tobiasahlin/SpinKit for how-to\nvar Spinner = React.createClass({\n  getDefaultProps() {\n    return {size: 6, spacing: 2}\n  },\n\n  render() {\n    var bounceSize = this.props.size + 'px'\n    var bounceStyle = {height: bounceSize, width: bounceSize, marginRight: this.props.spacing + 'px'}\n    return <div className=\"Spinner\" style={{width: ((Number(this.props.size) + Number(this.props.spacing)) * 3) + 'px'}}>\n      <div className=\"bounce1\" style={bounceStyle}/>\n      <div className=\"bounce2\" style={bounceStyle}/>\n      <div className=\"bounce3\" style={bounceStyle}/>\n    </div>\n  }\n})\n\nmodule.exports = Spinner\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Spinner.jsx\n **/","/**\n * Creates a className string including some class names conditionally.\n * @param {string=} staticClassName class name(s) which should always be\n *   included.\n * @param {Object.<string, *>} conditionalClassNames an object mapping class\n *   names to a value which indicates if the class name should be included -\n *   class names will be included if their corresponding value is truthy.\n * @return {string}\n */\nfunction buildClassName(staticClassName, conditionalClassNames) {\n  var classNames = []\n  if (typeof conditionalClassNames == 'undefined') {\n    conditionalClassNames = staticClassName\n  }\n  else {\n    classNames.push(staticClassName)\n  }\n  var classNameKeys = Object.keys(conditionalClassNames)\n  for (var i = 0, l = classNameKeys.length; i < l; i++) {\n    if (conditionalClassNames[classNameKeys[i]]) {\n      classNames.push(classNameKeys[i])\n    }\n  }\n  return classNames.join(' ')\n}\n\nmodule.exports = buildClassName\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/buildClassName.js\n **/","function extend(dest, src1, src2) {\n  var props = Object.keys(src1)\n  for (var i = 0, l = props.length; i < l; i++) {\n    dest[props[i]] = src1[props[i]]\n  }\n  if (src2) {\n    props = Object.keys(src2)\n    for (i = 0, l = props.length; i < l; i++) {\n      dest[props[i]] = src2[props[i]]\n    }\n  }\n  return dest\n}\n\nmodule.exports = extend\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/extend.js\n **/","var {SITE_TITLE} = require('./constants')\n\nfunction setTitle(title) {\n  document.title = (title ? title + ' | ' + SITE_TITLE : SITE_TITLE)\n}\n\nmodule.exports = setTitle\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/setTitle.js\n **/","var {EventEmitter} = require('events')\n\nvar HNService = require('../services/HNService')\n\nvar extend = require('../utils/extend')\n\n/**\n * Firebase reference used to stream updates - only one StoryStore instance can\n * be active at a time.\n */\nvar firebaseRef = null\n\n// Cache objects shared among StoryStore instances, also accessible via static\n// functions on the StoryStore constructor.\n\n/**\n * Story ids by type, in rank order. Persisted to sessionStorage.\n * @type Object.<type, Array.<id>>\n */\nvar idCache = {}\n\n/**\n * Item cache. Persisted to sessionStorage.\n * @type Object.<id, item>\n */\nvar itemCache = {}\n\n/**\n * Story items in rank order for display, by type.\n * @type Object.<type, Array.<item>>\n */\nvar storyLists = {}\n\n/**\n * Populate the story list for the given story type from the cache.\n */\nfunction populateStoryList(type) {\n  var ids = idCache[type]\n  var storyList = storyLists[type]\n  for (var i = 0, l = ids.length; i < l; i++) {\n    storyList[i] = itemCache[ids[i]] || null\n  }\n}\n\nfunction parseJSON(json, defaultValue) {\n  return (json ? JSON.parse(json) : defaultValue)\n}\n\nclass StoryStore extends EventEmitter {\n  constructor(type) {\n    super()\n    this.type = type\n\n    // Ensure cache objects for this type are initialised\n    if (!(type in idCache)) {\n      idCache[type] = []\n    }\n    if (!(type in storyLists)) {\n      storyLists[type] = []\n      populateStoryList(type)\n    }\n\n    // Pre-bind event handlers per instance\n    this.onStorage = this.onStorage.bind(this)\n    this.onStoriesUpdated = this.onStoriesUpdated.bind(this)\n  }\n\n  getState() {\n    return {\n      ids: idCache[this.type],\n      stories: storyLists[this.type]\n    }\n  }\n\n  itemUpdated(item, index) {\n    storyLists[this.type][index] = item\n    itemCache[item.id] = item\n  }\n\n  /**\n   * Emit an item id event if a storage key corresponding to an item in the\n   * cache has changed.\n   */\n  onStorage(e) {\n    if (itemCache[e.key]) {\n      this.emit(e.key)\n    }\n  }\n\n  /**\n   * Handle story id snapshots from Firebase.\n   */\n  onStoriesUpdated(snapshot) {\n    idCache[this.type] = snapshot.val()\n    populateStoryList(this.type)\n    this.emit('update', this.getState())\n  }\n\n  start() {\n    firebaseRef = HNService.storiesRef(this.type)\n    firebaseRef.on('value', this.onStoriesUpdated)\n    window.addEventListener('storage', this.onStorage)\n  }\n\n  stop() {\n    if (firebaseRef !== null) {\n      firebaseRef.off()\n      firebaseRef = null\n    }\n    window.removeEventListener('storage', this.onStorage)\n  }\n}\n\n// Static, cache-related functions\nextend(StoryStore, {\n  /**\n   * Get an item from the cache.\n   */\n  getItem(id) {\n    return itemCache[id] || null\n  },\n\n  /**\n   * Deserialise caches from sessionStorage.\n   */\n  loadSession() {\n    idCache = parseJSON(window.sessionStorage.idCache, {})\n    itemCache = parseJSON(window.sessionStorage.itemCache, {})\n  },\n\n  /**\n   * Serialise caches to sessionStorage as JSON.\n   */\n  saveSession() {\n    window.sessionStorage.idCache = JSON.stringify(idCache)\n    window.sessionStorage.itemCache = JSON.stringify(itemCache)\n  }\n})\n\nmodule.exports = StoryStore\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/stores/StoryStore.js\n **/","var EventEmitter = require('events').EventEmitter\n\nvar HNService = require('../services/HNService')\n\nvar {UPDATES_CACHE_SIZE} = require('../utils/constants')\nvar extend = require('../utils/extend')\n\n/**\n * Firebase reference used to stream updates.\n */\nvar updatesRef = null\n\n/**\n * Contains item id -> item cache objects. Persisted to sessionStorage.\n * @prop .comments {Object.<id,item>} comments cache.\n * @prop .stories {Object.<id,item>} story cache.\n */\nvar updatesCache = null\n\n/**\n * Lists of items in reverse chronological order for display.\n * @prop .comments {Array.<item>} comment updates.\n * @prop .stories {Array.<item>} story updates.\n */\nvar updates = {}\n\nfunction sortByTimeDesc(a, b) {\n  return b.time - a.time\n}\n\nfunction cacheObjToSortedArray(obj) {\n  var arr = Object.keys(obj).map(function(id) { return obj[id] })\n  arr.sort(sortByTimeDesc)\n  return arr\n}\n\n/**\n * Populate lists of updates for display from the cache.\n */\nfunction populateUpdates() {\n  updates.comments = processCacheObj(updatesCache.comments)\n  updates.stories = processCacheObj(updatesCache.stories)\n}\n\n/**\n * Create an array of items from a cache object, sorted in reverse chronological\n * order. Evict the oldest items from the cache if it's grown above\n * UPDATES_CACHE_SIZE.\n */\nfunction processCacheObj(cacheObj) {\n  var arr = cacheObjToSortedArray(cacheObj)\n  arr.splice(UPDATES_CACHE_SIZE, Math.max(0, arr.length - UPDATES_CACHE_SIZE))\n     .forEach(function(item) {\n       delete cacheObj[item.id]\n     })\n  return arr\n}\n\n/**\n * Lookup to filter out any items which appear in the updates feed which can't\n * be displayed by the Updates component.\n */\nvar updateItemTypes = {\n  comment: true,\n  job: true,\n  poll: true,\n  story: true\n}\n\n/**\n * Process incoming items from the update stream.\n */\nfunction handleUpdateItems(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    var item = items[i]\n    // Silently ignore deleted items (because irony)\n    if (item.deleted) { continue }\n\n    if (typeof updateItemTypes[item.type] == 'undefined') {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          \"An item which can't be displayed by the Updates component was \" +\n          'received in the updates stream: ' + JSON.stringify(item)\n        )\n      }\n      continue\n    }\n\n    if (item.type === 'comment') {\n      updatesCache.comments[item.id] = item\n    }\n    else {\n      updatesCache.stories[item.id] = item\n    }\n  }\n\n  populateUpdates()\n  UpdatesStore.emit('updates', updates)\n}\n\nvar UpdatesStore = extend(new EventEmitter(), {\n  loadSession() {\n    var json = window.sessionStorage.updates\n    updatesCache = (json ? JSON.parse(json) : {comments: {}, stories: {}})\n    populateUpdates()\n  },\n\n  saveSession() {\n    window.sessionStorage.updates = JSON.stringify(updatesCache)\n  },\n\n  start() {\n    if (updatesRef === null) {\n      updatesRef = HNService.updatesRef()\n      updatesRef.on('value', function(snapshot) {\n        HNService.fetchItems(snapshot.val(), handleUpdateItems)\n      })\n    }\n  },\n\n  stop() {\n    updatesRef.off()\n    updatesRef = null\n  },\n\n  getUpdates() {\n    return updates\n  },\n\n  getItem(id) {\n    return (updatesCache.comments[id] || updatesCache.stories[id] || null)\n  },\n\n  getComment(id) {\n    return (updatesCache.comments[id] || null)\n  },\n\n  getStory(id) {\n    return (updatesCache.stories[id] || null)\n  }\n})\nUpdatesStore.off = UpdatesStore.removeListener\n\nmodule.exports = UpdatesStore\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/stores/UpdatesStore.js\n **/","module.exports = {\n  ITEMS_PER_PAGE: 30,\n  SITE_TITLE: 'React HN',\n  UPDATES_CACHE_SIZE: 500\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/constants.js\n **/","function pluralise(howMany, suffixes) {\n  return (suffixes || ',s').split(',')[(howMany === 1 ? 0 : 1)]\n}\n\nmodule.exports = pluralise\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/pluralise.js\n **/","var React = require('react')\nvar {Link} = require('react-router')\nvar TimeAgo = require('react-timeago')\n\nvar ItemStore = require('../stores/ItemStore')\nvar SettingsStore = require('../stores/SettingsStore')\n\nvar Spinner = require('../Spinner')\n\nvar pluralise = require('../utils/pluralise')\n\nvar CommentMixin = {\n  fetchAncestors(comment) {\n    ItemStore.fetchCommentAncestors(comment, result => {\n      if (\"production\" !== process.env.NODE_ENV) {\n        console.info(\n          'fetchAncestors(' + comment.id + ') took ' +\n          result.timeTaken + ' ms for ' +\n          result.itemCount + ' item' + pluralise(result.itemCount) + ' with ' +\n          result.cacheHits + ' cache hit' + pluralise(result.cacheHits) + ' ('  +\n          (result.cacheHits / result.itemCount * 100).toFixed(1) + '%)'\n        )\n      }\n      if (!this.isMounted()) {\n        if (\"production\" !== process.env.NODE_ENV) {\n          console.info(\"...but the comment isn't mounted\")\n        }\n        // Too late - the comment or the user has moved elsewhere\n        return\n      }\n      this.setState({\n        parent: result.parent\n      , op: result.op\n      })\n    })\n  },\n\n  renderCommentLoading(comment) {\n    return <div className={'Comment Comment--loading Comment--level' + this.props.level}>\n      {(this.props.loadingSpinner || comment.delayed) && <Spinner size=\"20\"/>}\n      {comment.delayed && <div className=\"Comment__text\">\n        Unable to load comment &ndash; this usually indicates the author has configured a delay.\n        Trying again in 30 seconds.\n      </div>}\n    </div>\n  },\n\n  renderCommentDeleted(comment, options) {\n    return <div className={options.className}>\n      <div className=\"Comment__content\">\n        <div className=\"Comment__meta\">\n          [deleted] | <a href={'https://news.ycombinator.com/item?id=' + comment.id}>view on Hacker News</a>\n        </div>\n      </div>\n    </div>\n  },\n\n  renderError(comment, options) {\n    return <div className={options.className}>\n      <div className=\"Comment__content\">\n        <div className=\"Comment__meta\">\n          [error] | comment is {JSON.stringify(comment)} | <a href={'https://news.ycombinator.com/item?id=' + options.id}>view on Hacker News</a>\n        </div>\n      </div>\n    </div>\n  },\n\n  renderCollapseControl(collapsed) {\n    return <span className=\"Comment__collapse\" onClick={this.toggleCollapse} onKeyPress={this.toggleCollapse} tabIndex=\"0\">\n      [{collapsed ? '+' : '–'}]\n    </span>\n  },\n\n  /**\n   * @param options.collapsible {Boolean} if true, assumes this.toggleCollspse()\n   * @param options.collapsed {Boolean}\n   * @param options.link {Boolean}\n   * @param options.parent {Boolean} if true, assumes this.state.parent\n   * @param options.op {Boolean} if true, assumes this.state.op\n   * @param options.childCounts {Object} with .children and .newComments\n   */\n  renderCommentMeta(comment, options) {\n    if (comment.dead && !SettingsStore.showDead) {\n      return <div className=\"Comment__meta\">\n        {options.collapsible && this.renderCollapseControl(options.collapsed)}\n        {options.collapsible && ' '}\n        [dead]\n        {options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren')}\n          {options.childCounts && options.childCounts.newComments > 0 && ', '}\n          {options.childCounts && options.childCounts.newComments > 0 && <em>{options.childCounts.newComments} new</em>}\n        {options.childCounts && ')'}\n      </div>\n    }\n\n    return <div className=\"Comment__meta\">\n      {options.collapsible && this.renderCollapseControl(options.collapsed)}\n      {options.collapsible && ' '}\n      <Link to={`/user/${comment.by}`} className=\"Comment__user\">{comment.by}</Link>{' '}\n      <TimeAgo date={comment.time * 1000}/>\n      {options.link && ' | '}\n      {options.link && <Link to={`/comment/${comment.id}`}>link</Link>}\n      {options.parent && ' | '}\n      {options.parent && <Link to={`/${this.state.parent.type}/${comment.parent}`}>parent</Link>}\n      {options.op && ' | on: '}\n      {options.op && <Link to={`/${this.state.op.type}/${this.state.op.id}`}>{this.state.op.title}</Link>}\n      {comment.dead &&  ' | [dead]'}\n      {options.childCounts && ' | (' + options.childCounts.children + ' child' + pluralise(options.childCounts.children, ',ren')}\n        {options.childCounts && options.childCounts.newComments > 0 && ', '}\n        {options.childCounts && options.childCounts.newComments > 0 && <em>{options.childCounts.newComments} new</em>}\n      {options.childCounts && ')'}\n    </div>\n  },\n\n  renderCommentText(comment, options) {\n    return <div className=\"Comment__text\">\n      {(!comment.dead || SettingsStore.showDead) ? <div dangerouslySetInnerHTML={{__html: comment.text}}/> : '[dead]'}\n      {SettingsStore.replyLinks && options.replyLink && !comment.dead && <p>\n        <a href={`https://news.ycombinator.com/reply?id=${comment.id}`}>reply</a>\n      </p>}\n    </div>\n  }\n}\n\nmodule.exports =  CommentMixin\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/mixins/CommentMixin.jsx\n **/","var React = require('react')\nvar {Link} = require('react-router')\nvar TimeAgo = require('react-timeago')\n\nvar SettingsStore = require('../stores/SettingsStore')\nvar pluralise = require('../utils/pluralise')\n\nvar parseHost = (function() {\n  var a = document.createElement('a')\n  return function(url) {\n    a.href = url\n    var parts = a.hostname.split('.').slice(-3)\n    if (parts[0] === 'www') {\n      parts.shift()\n    }\n    return parts.join('.')\n  }\n})()\n\n/**\n * Reusable logic for displaying an item.\n */\nvar ItemMixin = {\n  /**\n   * Render an item's metadata bar.\n   */\n  renderItemMeta(item, extraContent) {\n    var itemDate = new Date(item.time * 1000)\n\n    if (item.type == 'job') {\n      return <div className=\"Item__meta\">\n        <TimeAgo date={itemDate} className=\"Item__time\"/>\n      </div>\n    }\n\n    return <div className=\"Item__meta\">\n      <span className=\"Item__score\">\n        {item.score} point{pluralise(item.score)}\n      </span>{' '}\n      <span className=\"Item__by\">\n        by <Link to={`/user/${item.by}`}>{item.by}</Link>\n      </span>{' '}\n      <TimeAgo date={itemDate} className=\"Item__time\"/>\n      {' | '}\n      <Link to={`/${item.type}/${item.id}`}>\n        {item.descendants > 0 ? item.descendants + ' comment' + pluralise(item.descendants) : 'discuss'}\n      </Link>\n      {extraContent}\n    </div>\n  },\n\n  /**\n   * Render an item's title bar.\n   */\n  renderItemTitle(item) {\n    var hasURL = !!item.url\n    var title\n    if (item.dead) {\n      title = '[dead] ' + item.title\n    }\n    else {\n      title = (hasURL ? <a href={item.url}>{item.title}</a>\n                      : <Link to={`/${item.type}/${item.id}`}>{item.title}</Link>)\n    }\n    return <div className=\"Item__title\" style={{fontSize: SettingsStore.titleFontSize}}>\n      {title}\n      {hasURL && ' '}\n      {hasURL && <span className=\"Item__host\">({parseHost(item.url)})</span>}\n    </div>\n  }\n}\n\nmodule.exports = ItemMixin\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/mixins/ItemMixin.jsx\n **/","var extend = require('../utils/extend')\n\nfunction CommentThreadStore(item, onCommentsChanged) {\n  this.itemId = item.id\n  this.onCommentsChanged = onCommentsChanged\n\n  /**\n   * Lookup from a comment id to its child comment ids.\n   * @type {Object.<id,Array.<Number>>}\n   */\n  this.children = {}\n  this.children[item.id] = []\n\n  /**\n   * Lookup for new comment ids. Will only contain true.\n   * @type {Object.<id,Boolean>}\n   */\n  this.isNew = {}\n\n  /**\n   * Lookup for collapsed state of comment ids. May contain true or false.\n   * @type {Object.<id,Boolean>}\n   */\n  this.isCollapsed = {}\n}\n\nextend(CommentThreadStore.prototype, {\n  /**\n   * Get counts of children and new comments under the given comment.\n   * @return .children {Number}\n   * @return .newComments {Number}\n   */\n  getChildCounts(comment) {\n    var childCount = 0\n    var newCommentCount = 0\n    var nodes = [comment.id]\n\n    while (nodes.length) {\n      var nextNodes = []\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var nodeChildren = this.children[nodes[i]]\n        if (nodeChildren.length) {\n          nextNodes.push.apply(nextNodes, nodeChildren)\n        }\n      }\n      for (i = 0, l = nextNodes.length; i < l; i++) {\n        if (this.isNew[nextNodes[i]]) {\n          newCommentCount++\n        }\n      }\n      childCount += nextNodes.length\n      nodes = nextNodes\n    }\n\n    return {\n      children: childCount,\n      newComments: newCommentCount\n    }\n  },\n\n  /**\n   * Register a comment's appearance in the thread.\n   */\n  commentAdded(comment) {\n    if (comment.deleted) { return }\n\n    this.children[comment.id] = []\n    this.children[comment.parent].push(comment.id)\n  },\n\n  /**\n   * Register a comment's deletion from the thread.\n   */\n  commentDeleted(comment) {\n    // Comments which initially failed to load (null from Firebase API) can be\n    // deleted by the time the API catches up.\n    if (!comment) { return }\n\n    var siblings = this.children[comment.parent]\n    siblings.splice(siblings.indexOf(comment.id), 1)\n  },\n\n  toggleCollapse(commentId) {\n    this.isCollapsed[commentId] = !this.isCollapsed[commentId]\n    this.onCommentsChanged({type: 'collapse'})\n  }\n})\n\nmodule.exports = CommentThreadStore\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/stores/CommentThreadStore.js\n **/","var CommentThreadStore = require('./CommentThreadStore')\nvar SettingsStore = require('./SettingsStore')\n\nvar debounce = require('../utils/cancellableDebounce')\nvar extend = require('../utils/extend')\nvar pluralise = require('../utils/pluralise')\nvar storage = require('../utils/storage')\n\n/**\n * Load persisted comment thread state.\n * @return .lastVisit {Date} null if the item hasn't been visited before.\n * @return .commentCount {Number} 0 if the item hasn't been visited before.\n * @return .maxCommentId {Number} 0 if the item hasn't been visited before.\n */\nfunction loadState(itemId) {\n  var json = storage.get(itemId)\n  if (json) {\n    return JSON.parse(json)\n  }\n  return {\n    lastVisit: null,\n    commentCount: 0,\n    maxCommentId: 0\n  }\n}\n\nfunction StoryCommentThreadStore(item, onCommentsChanged, options) {\n  CommentThreadStore.call(this, item, onCommentsChanged)\n  this.startedLoading = Date.now()\n\n  /** Lookup from a comment id to its parent comment id. */\n  this.parents = {}\n  /** The number of comments which have loaded. */\n  this.commentCount = 0\n  /** The number of new comments which have loaded. */\n  this.newCommentCount = 0\n  /** The max comment id seen by the store. */\n  this.maxCommentId = 0\n  /** Has the comment thread finished loading? */\n  this.loading = true\n  /** The number of comments we're expecting to load. */\n  this.expectedComments = item.kids ? item.kids.length : 0\n  /**\n   * The number of descendants the story has according to the API.\n   * This count includes deleted comments, which aren't accessible via the API,\n   * so a thread with deleted comments (example story id: 9273709) will never\n   * load this number of comments\n   * However, we still need to persist the last known descendant count in order\n   * to determine how many new comments there are when displaying the story on a\n   * list page.\n   */\n  this.itemDescendantCount = item.descendants\n\n  var initialState = loadState(item.id)\n  /** Time of last visit to the story. */\n  this.lastVisit = initialState.lastVisit\n  /** Max comment id on the last visit - determines which comments are new. */\n  this.prevMaxCommentId = initialState.maxCommentId\n  /** Is this the user's first time viewing the story? */\n  this.isFirstVisit = (initialState.lastVisit === null)\n\n  // Trigger an immediate check for thread load completion if the item was not\n  // retrieved from the cache, so is the latest version. This completes page\n  // loading immediately for items which have no comments yet.\n  if (!options.cached) {\n    this.checkLoadCompletion()\n  }\n}\n\nStoryCommentThreadStore.loadState = loadState\n\nStoryCommentThreadStore.prototype = extend(Object.create(CommentThreadStore.prototype), {\n  constructor: StoryCommentThreadStore,\n\n  /**\n   * Callback to the item component with updated comment counts, debounced as\n   * comments will be loading frequently on initial load.\n   */\n  numberOfCommentsChanged: debounce(function() {\n    this.onCommentsChanged({type: 'number'})\n  }, 123),\n\n  /**\n   * If we don't have a last visit time stored for an item, it must have been\n   * visited for the first time. Once it finishes loading, establish the last\n   * visit time and max comment id which will be used to track and display new\n   * comments.\n   */\n  firstLoadComplete() {\n    this.lastVisit = Date.now()\n    this.prevMaxCommentId = this.maxCommentId\n    this.isFirstVisit = false\n    this.onCommentsChanged({type: 'first_load_complete'})\n  },\n\n  /**\n   * Check whether the number of comments has reached the expected number yet.\n   */\n  checkLoadCompletion() {\n    if (this.loading && this.commentCount >= this.expectedComments) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.info(\n          'Initial load of ' +\n           this.commentCount + ' comment' + pluralise(this.commentCount) +\n          ' for ' + this.itemId + ' took ' +\n          ((Date.now() - this.startedLoading) / 1000).toFixed(2) + 's'\n        )\n      }\n      this.loading = false\n      if (this.isFirstVisit) {\n        this.firstLoadComplete()\n      }\n      else if (SettingsStore.autoCollapse && this.newCommentCount > 0) {\n        this.collapseThreadsWithoutNewComments()\n      }\n      this._storeState()\n    }\n  },\n\n  /**\n   * Persist comment thread state.\n   */\n  _storeState() {\n    storage.set(this.itemId, JSON.stringify({\n      lastVisit: Date.now(),\n      commentCount: this.itemDescendantCount,\n      maxCommentId: this.maxCommentId\n    }))\n  },\n\n  /**\n   * The item this comment thread belongs to got updated.\n   */\n  itemUpdated(item) {\n    this.itemDescendantCount = item.descendants\n  },\n\n  /**\n   * A comment got loaded initially or added later.\n   */\n  commentAdded(comment) {\n    // Deleted comments don't count towards the comment count\n    if (comment.deleted) {\n      // Adjust the number of comments expected during the initial page load.\n      if (this.loading) {\n        this.expectedComments--\n        this.checkLoadCompletion()\n      }\n      return\n    }\n\n    CommentThreadStore.prototype.commentAdded.call(this, comment)\n\n    // Dead comments don't contribute to the comment count if showDead is off\n    if (comment.dead && !SettingsStore.showDead) {\n      this.expectedComments--\n    }\n    else {\n      this.commentCount++\n    }\n    // Add the number of kids the comment has to the expected total for the\n    // initial load.\n    if (this.loading && comment.kids) {\n      this.expectedComments += comment.kids.length\n    }\n    // Register the comment as new if it's new, unless it's dead and showDead is off\n    if (this.prevMaxCommentId > 0 &&\n        comment.id > this.prevMaxCommentId &&\n        (!comment.dead || SettingsStore.showDead)) {\n      this.newCommentCount++\n      this.isNew[comment.id] = true\n    }\n    // Keep track of the biggest comment id seen\n    if (comment.id > this.maxCommentId) {\n      this.maxCommentId = comment.id\n    }\n    // We don't want the story to be part of the comment parent hierarchy\n    if (comment.parent !== this.itemId) {\n      this.parents[comment.id] = comment.parent\n    }\n\n    this.numberOfCommentsChanged()\n    if (this.loading) {\n      this.checkLoadCompletion()\n    }\n  },\n\n  /**\n   * A comment which hasn't loaded yet is being delayed.\n   */\n  commentDelayed(commentId) {\n    // Don't wait for delayed comments\n    this.expectedComments--\n  },\n\n  /**\n   * A comment which wasn't previously deleted became deleted.\n   */\n  commentDeleted(comment) {\n    CommentThreadStore.prototype.commentDeleted.call(this, comment)\n    this.commentCount--\n    if (this.isNew[comment.id]) {\n      this.newCommentCount--\n      delete this.isNew[comment.id]\n    }\n    delete this.parents[comment.id]\n    // Trigger debounced callbacks\n    this.numberOfCommentsChanged()\n  },\n\n  /**\n   * A comment which wasn't previously dead became dead.\n   */\n  commentDied(comment) {\n    if (!SettingsStore.showDead) {\n      this.commentCount--\n      if (this.isNew[comment.id]) {\n        this.newCommentCount--\n        delete this.isNew[comment.id]\n      }\n    }\n  },\n\n  /**\n   * Change the expected number of comments if an update was received during\n   * initial loding and trigger a re-check of loading completion.\n   */\n  adjustExpectedComments(change) {\n    this.expectedComments += change\n    this.checkLoadCompletion()\n  },\n\n  collapseThreadsWithoutNewComments() {\n    // Create an id lookup for comments which have a new comment as one of their\n    // descendants. New comments themselves are not added to the lookup.\n    var newCommentIds = Object.keys(this.isNew)\n    var hasNewComments = {}\n    for (var i = 0, l = newCommentIds.length; i < l; i++) {\n      var parent = this.parents[newCommentIds[i]]\n      while (parent) {\n        // Stop when we hit one we've seen before\n        if (hasNewComments[parent]) {\n          break\n        }\n        hasNewComments[parent] = true\n        parent = this.parents[parent]\n      }\n    }\n\n    // Walk the tree of comments one level at a time, only walking children to\n    // comments we know have new comment descendants, to find subtrees which\n    // don't have new comments.\n    // Other comments are marked for collapsing unless they are themselves a\n    // new comment (in which case all their replies must be new too).\n    var shouldCollapse = {}\n    var commentIds = this.children[this.itemId]\n    while (commentIds.length) {\n      var nextCommentIds = []\n      for (i = 0, l = commentIds.length; i < l; i++) {\n        var commentId = commentIds[i]\n        if (!hasNewComments[commentId]) {\n          if (!this.isNew[commentId]) {\n            shouldCollapse[commentId] = true\n          }\n        }\n        else {\n          var childCommentIds = this.children[commentId]\n          if (childCommentIds.length) {\n            nextCommentIds.push.apply(nextCommentIds, childCommentIds)\n          }\n        }\n      }\n      commentIds = nextCommentIds\n    }\n\n    this.isCollapsed = shouldCollapse\n    this.onCommentsChanged({type: 'collapse'})\n  },\n\n  /**\n   * Merk the thread as read.\n   */\n  markAsRead() {\n    this.lastVisit = Date.now()\n    this.newCommentCount = 0\n    this.prevMaxCommentId = this.maxCommentId\n    this.isNew = {}\n    this._storeState()\n  },\n\n  /**\n   * Persist comment thread state and perform any necessary internal cleanup.\n   */\n  dispose() {\n    // Cancel debounced callbacks in case any are pending\n    this.numberOfCommentsChanged.cancel()\n    this._storeState()\n  }\n})\n\nmodule.exports = StoryCommentThreadStore\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/stores/StoryCommentThreadStore.js\n **/","var React = require('react')\nvar ReactFireMixin = require('reactfire')\n\nvar CommentThreadStore = require('./stores/CommentThreadStore')\nvar HNService = require('./services/HNService')\nvar SettingsStore = require('./stores/SettingsStore')\n\nvar CommentMixin = require('./mixins/CommentMixin')\n\nvar cx = require('./utils/buildClassName')\n\n/**\n * A comment in a thread.\n */\nvar Comment = React.createClass({\n  mixins: [CommentMixin, ReactFireMixin],\n\n  propTypes: {\n    id: React.PropTypes.number.isRequired\n  , level: React.PropTypes.number.isRequired\n  , loadingSpinner: React.PropTypes.bool\n  , threadStore: React.PropTypes.instanceOf(CommentThreadStore).isRequired\n  },\n\n  getDefaultProps() {\n    return {\n      loadingSpinner: false\n    }\n  },\n\n  getInitialState() {\n    return {\n      comment: {}\n    }\n  },\n\n  componentWillMount() {\n    this.bindFirebaseRef()\n  },\n\n  componentWillUnmount() {\n    this.clearDelayTimeout()\n  },\n\n  componentDidUpdate(prevProps, prevState) {\n    // Huge, fast-growing threads like https://news.ycombinator.com/item?id=9784470\n    // seem to break the API - some comments are coming back from Firebase as null.\n    if (!this.state.comment) {\n      this.props.threadStore.adjustExpectedComments(-1)\n      return\n    }\n\n    // On !prevState.comment: a comment which was initially null - see\n    // above - may eventually load when the API catches up.\n    if (!prevState.comment || !prevState.comment.id) {\n      // Register a newly-loaded comment with the thread store\n      if (this.state.comment.id) {\n        // If the comment was delayed, cancel any pending timeout\n        if (prevState.comment && prevState.comment.delayed) {\n          this.clearDelayTimeout()\n        }\n        this.props.threadStore.commentAdded(this.state.comment)\n      }\n      if (prevState.comment && !prevState.comment.delayed && this.state.comment.delayed) {\n        this.props.threadStore.commentDelayed(this.props.id)\n      }\n    }\n    // The comment was already loaded, look for changes to it\n    else {\n      if (!prevState.comment.deleted && this.state.comment.deleted) {\n        this.props.threadStore.commentDeleted(this.state.comment)\n      }\n      if (!prevState.comment.dead && this.state.comment.dead) {\n        this.props.threadStore.commentDied(this.state.comment)\n      }\n      // If the comment has been updated and the initial set of comments is\n      // still loading, the number of expected comments might need to be\n      // adjusted.\n      else if (prevState.comment !== this.state.comment &&\n               this.props.threadStore.loading) {\n        var kids = (this.state.comment.kids ? this.state.comment.kids.length : 0)\n        var prevKids = (prevState.comment.kids ? prevState.comment.kids.length : 0)\n        this.props.threadStore.adjustExpectedComments(kids - prevKids)\n      }\n    }\n  },\n\n  bindFirebaseRef() {\n    this.bindAsObject(HNService.itemRef(this.props.id), 'comment', this.handleFirebaseRefCancelled)\n    if (this.timeout) {\n      this.timeout = null\n    }\n  },\n\n  /**\n   * This is usually caused by a permissions error loading the comment due to\n   * its author using the delay setting (note: this is conjecture), which is\n   * measured in minutes - try again in 30 seconds.\n   */\n  handleFirebaseRefCancelled(e) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      console.error('Firebase ref for comment ' + this.props.id + ' was cancelled: ' + e.message)\n    }\n    this.unbind('comment')\n    this.timeout = setTimeout(this.bindFirebaseRef, 30000)\n    if (this.state.comment && !this.state.comment.delayed) {\n      this.state.comment.delayed = true\n      this.forceUpdate()\n    }\n  },\n\n  clearDelayTimeout() {\n    if (this.timeout) {\n      clearTimeout(this.timeout)\n      this.timeout = null\n    }\n  },\n\n  toggleCollapse(e) {\n    e.preventDefault()\n    this.props.threadStore.toggleCollapse(this.state.comment.id)\n  },\n\n  render() {\n    var comment = this.state.comment\n    var props = this.props\n    if (!comment) {\n      return this.renderError(comment, {\n        id: this.props.id,\n        className: 'Comment Comment--error Comment--level' + props.level\n      })\n    }\n    // Render a placeholder while we're waiting for the comment to load\n    if (!comment.id) { return this.renderCommentLoading(comment) }\n    // Don't show dead coments or their children, when configured\n    if (comment.dead && !SettingsStore.showDead) { return null }\n    // Render a link to HN for deleted comments if they're being displayed\n    if (comment.deleted) {\n      if (!SettingsStore.showDeleted) { return null }\n      return this.renderCommentDeleted(comment, {\n        className: 'Comment Comment--deleted Comment--level' + props.level\n      })\n    }\n\n    var isNew = props.threadStore.isNew[comment.id]\n    var collapsed = !!props.threadStore.isCollapsed[comment.id]\n    var childCounts = (collapsed && props.threadStore.getChildCounts(comment))\n    if (collapsed && isNew) { childCounts.newComments = 0 }\n    var className = cx('Comment Comment--level' + props.level, {\n      'Comment--collapsed': collapsed\n    , 'Comment--dead': comment.dead\n    , 'Comment--new': isNew\n    })\n\n    return <div className={className}>\n      <div className=\"Comment__content\">\n        {this.renderCommentMeta(comment, {\n          collapsible: true\n        , collapsed: collapsed\n        , link: true\n        , childCounts: childCounts\n        })}\n        {this.renderCommentText(comment, {replyLink: true})}\n      </div>\n      {comment.kids && <div className=\"Comment__kids\">\n        {comment.kids.map(function(id) {\n          return <Comment key={id} id={id}\n            level={props.level + 1}\n            loadingSpinner={props.loadingSpinner}\n            threadStore={props.threadStore}\n          />\n        })}\n      </div>}\n    </div>\n  }\n})\n\nmodule.exports = Comment\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Comment.jsx\n **/","var React = require('react')\nvar {Link} = require('react-router')\n\nvar Paginator = React.createClass({\n  _onClick(e) {\n    setTimeout(function() { window.scrollTo(0, 0) }, 0)\n  },\n\n  render() {\n    if (this.props.page == 1 && !this.props.hasNext) { return null }\n    return <div className=\"Paginator\">\n      {this.props.page > 1 && <span className=\"Paginator__prev\">\n        <Link to={`/${this.props.route}`} query={{page: this.props.page - 1}} onClick={this._onClick}>Prev</Link>\n      </span>}\n      {this.props.page > 1 && this.props.hasNext && ' | '}\n      {this.props.hasNext && <span className=\"Paginator__next\">\n        <Link to={`/${this.props.route}`} query={{page: this.props.page + 1}} onClick={this._onClick}>More</Link>\n      </span>}\n    </div>\n  }\n})\n\nmodule.exports = Paginator\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Paginator.jsx\n **/","var React = require('react')\nvar {Link} = require('react-router')\n\nvar SettingsStore = require('../stores/SettingsStore')\nvar cx = require('../utils/buildClassName')\n\n/**\n * Reusable logic for displaying an item in a list.\n * Must be used in conjunction with ItemMixin for its rendering methods.\n */\nvar ListItemMixin = {\n  getNewCommentCount(item, threadState) {\n    if (threadState.lastVisit === null) {\n      return 0\n    }\n    return item.descendants - threadState.commentCount\n  },\n\n  renderListItem(item, threadState) {\n    if (item.deleted) { return null }\n    var newCommentCount = this.getNewCommentCount(item, threadState)\n    return <li className={cx('ListItem', {'ListItem--dead': item.dead})} style={{marginBottom: SettingsStore.listSpacing}}>\n      {this.renderItemTitle(item)}\n      {this.renderItemMeta(item, (newCommentCount > 0 && <span className=\"ListItem__newcomments\">{' '}\n        (<Link to={`/${item.type}/${item.id}`}>\n          {newCommentCount} new\n        </Link>)\n      </span>))}\n    </li>\n  }\n}\n\nmodule.exports = ListItemMixin\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/mixins/ListItemMixin.jsx\n **/","var PageNumberMixin = {\n  getPageNumber(page) {\n    if (typeof page == 'undefined') {\n      page = this.props.location.query.page\n    }\n    return (page && /^\\d+$/.test(page) ? Math.max(1, Number(page)) : 1)\n  }\n}\n\nmodule.exports = PageNumberMixin\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/mixins/PageNumberMixin.js\n **/","var HNService = require('../services/HNService')\n\nvar StoryStore = require('./StoryStore')\nvar UpdatesStore = require('./UpdatesStore')\n\nvar commentParentLookup = {}\nvar titleCache = {}\n\nfunction fetchCommentParent(comment, cb, result) {\n  var commentId = comment.id\n  var parentId = comment.parent\n\n  while (commentParentLookup[parentId] || titleCache[parentId]) {\n    // We just saved ourselves an item fetch\n    result.itemCount++\n    result.cacheHits++\n\n    // The parent is a known non-comment\n    if (titleCache[parentId]) {\n      if (result.itemCount === 1) { result.parent = titleCache[parentId] }\n      result.op = titleCache[parentId]\n      cb(result)\n      return\n    }\n\n    // The parent is a known comment\n    if (commentParentLookup[parentId]) {\n      if (result.itemCount === 1) { result.parent = {id: parentId, type: 'comment'} }\n      // Set the parent comment's ids up for the next iteration\n      commentId = parentId\n      parentId = commentParentLookup[parentId]\n    }\n  }\n\n  // The parent of the current comment isn't known, so we'll have to fetch it\n  ItemStore.getItem(parentId, function(parent) {\n    result.itemCount++\n    // Add the current comment's parent to the lookup for next time\n    commentParentLookup[commentId] = parentId\n    if (parent.type === 'comment') {\n      commentParentLookup[parent.id] = parent.parent\n    }\n    processCommentParent(parent, cb, result)\n  }, result)\n}\n\nfunction processCommentParent(item, cb, result) {\n  if (result.itemCount === 1) {\n    result.parent = item\n  }\n  if (item.type !== 'comment') {\n    result.op = item\n    titleCache[item.id] = {\n      id: item.id,\n      type: item.type,\n      title: item.title\n    }\n    cb(result)\n  }\n  else {\n    fetchCommentParent(item, cb, result)\n  }\n}\n\nvar ItemStore = {\n  getItem(id, cb, result) {\n    var cachedItem = this.getCachedItem(id)\n    if (cachedItem) {\n      if (result) {\n        result.cacheHits++\n      }\n      setImmediate(cb, cachedItem)\n    }\n    else {\n      HNService.fetchItem(id, cb)\n    }\n  },\n\n  getCachedItem(id) {\n    return StoryStore.getItem(id) || UpdatesStore.getItem(id) || null\n  },\n\n  getCachedStory(id) {\n    return StoryStore.getItem(id) || UpdatesStore.getStory(id) || null\n  },\n\n  fetchCommentAncestors(comment, cb) {\n    var startTime = Date.now()\n    var result = {itemCount: 0, cacheHits: 0}\n    fetchCommentParent(comment, function() {\n      result.timeTaken = Date.now() - startTime\n      setImmediate(cb, result)\n    }, result)\n  }\n}\n\nmodule.exports = ItemStore\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/stores/ItemStore.js\n **/","function pageCalc(pageNum, pageSize, numItems) {\n  var startIndex = (pageNum - 1) * pageSize\n  var endIndex = Math.min(numItems, startIndex + pageSize)\n  var hasNext = endIndex < numItems - 1\n  return {pageNum, startIndex, endIndex, hasNext}\n}\n\nmodule.exports = pageCalc\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/pageCalc.js\n **/","module.exports = {\n  get(key, defaultValue) {\n    var value = window.localStorage[key]\n    return (typeof value != 'undefined' ? value : defaultValue)\n  },\n  set(key, value) {\n    window.localStorage[key] = value\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/storage.js\n **/","var React = require('react')\n\nvar SettingsStore = require('./stores/SettingsStore')\n\nvar CommentMixin = require('./mixins/CommentMixin')\n\nvar cx = require('./utils/buildClassName')\n\n/**\n * Displays a standalone comment passed as a prop.\n */\nvar DisplayComment = React.createClass({\n  mixins: [CommentMixin],\n\n  propTypes: {\n    comment: React.PropTypes.object.isRequired\n  },\n\n  getInitialState() {\n    return {\n      op: {}\n    , parent: {type: 'comment'}\n    }\n  },\n\n  componentWillMount() {\n    this.fetchAncestors(this.props.comment)\n  },\n\n  render() {\n    if (this.props.comment.deleted) { return null }\n    if (this.props.comment.dead && !SettingsStore.showDead) { return null }\n\n    var comment = this.props.comment\n    var className = cx('Comment Comment--level0', {\n      'Comment--dead': comment.dead\n    })\n\n    return <div className={className}>\n      <div className=\"Comment__content\">\n        {this.renderCommentMeta(comment, {\n          link: true\n        , parent: !!this.state.parent.id && !!this.state.op.id && comment.parent != this.state.op.id\n        , op: !!this.state.op.id\n        })}\n        {this.renderCommentText(comment, {replyLink: false})}\n      </div>\n    </div>\n  }\n})\n\nmodule.exports = DisplayComment\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/DisplayComment.jsx\n **/","var React = require('react')\n\nvar StoryCommentThreadStore = require('./stores/StoryCommentThreadStore')\n\nvar ItemMixin = require('./mixins/ItemMixin')\nvar ListItemMixin = require('./mixins/ListItemMixin')\n\n/**\n * Display story title and metadata as a list item.\n * The story to display will be passed as a prop.\n */\nvar DisplayListItem = React.createClass({\n  mixins: [ItemMixin, ListItemMixin],\n\n  propTypes: {\n    item: React.PropTypes.object.isRequired\n  },\n\n  componentWillMount() {\n    this.threadState = StoryCommentThreadStore.loadState(this.props.item.id)\n  },\n\n  render() {\n    return this.renderListItem(this.props.item, this.threadState)\n  }\n})\n\nmodule.exports = DisplayListItem\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/DisplayListItem.jsx\n **/","var React = require('react')\nvar ReactFireMixin = require('reactfire')\nvar TimeAgo = require('react-timeago')\n\nvar HNService = require('./services/HNService')\nvar StoryCommentThreadStore = require('./stores/StoryCommentThreadStore')\nvar ItemStore = require('./stores/ItemStore')\n\nvar Comment = require('./Comment')\nvar PollOption = require('./PollOption')\nvar Spinner = require('./Spinner')\nvar ItemMixin = require('./mixins/ItemMixin')\n\nvar cx = require('./utils/buildClassName')\nvar setTitle = require('./utils/setTitle')\n\nfunction timeUnitsAgo(value, unit, suffix) {\n  if (value == 1) {\n    return unit\n  }\n  return `${value} ${unit}s`\n}\n\nvar Item = React.createClass({\n  mixins: [ItemMixin, ReactFireMixin],\n\n  getInitialState() {\n    return {\n      item: ItemStore.getCachedStory(Number(this.props.params.id)) || {}\n    }\n  },\n\n  componentWillMount() {\n    this.bindAsObject(HNService.itemRef(this.props.params.id), 'item')\n    if (this.state.item.id) {\n      this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, {cached: true})\n      setTitle(this.state.item.title)\n    }\n    window.addEventListener('beforeunload', this.handleBeforeUnload)\n  },\n\n  componentWillUnmount() {\n    if (this.threadStore) {\n      this.threadStore.dispose()\n    }\n    window.removeEventListener('beforeunload', this.handleBeforeUnload)\n  },\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.params.id != nextProps.params.id) {\n      // Tear it down...\n      this.threadStore.dispose()\n      this.threadStore = null\n      this.unbind('item')\n      // ...and set it up again\n      var item = ItemStore.getCachedStory(Number(nextProps.params.id))\n      if (item) {\n        this.threadStore = new StoryCommentThreadStore(item, this.handleCommentsChanged, {cached: true})\n        setTitle(item.title)\n      }\n      this.bindAsObject(HNService.itemRef(nextProps.params.id), 'item')\n      this.setState({item: item || {}})\n    }\n  },\n\n  componentWillUpdate(nextProps, nextState) {\n    // Update the title when the item has loaded.\n    if (!this.state.item.id && nextState.item.id) {\n      setTitle(nextState.item.title)\n    }\n  },\n\n  componentDidUpdate(prevProps, prevState) {\n    // If the state item id changed, an initial or new item must have loaded\n    if (prevState.item.id != this.state.item.id) {\n      if (!this.threadStore || this.threadStore.itemId != this.state.item.id) {\n        this.threadStore = new StoryCommentThreadStore(this.state.item, this.handleCommentsChanged, {cached: false})\n        setTitle(this.state.item.title)\n        this.forceUpdate()\n      }\n    }\n    else if (prevState.item !== this.state.item) {\n      // If the item has been updated from Firebase and the initial set\n      // of comments is still loading, the number of expected comments might\n      // need to be adjusted.\n      // This triggers a check for thread load completion, completing it\n      // immediately if a cached item had 0 kids and the latest version from\n      // Firebase also has 0 kids.\n      if (this.threadStore.loading) {\n        var kids = (this.state.item.kids ? this.state.item.kids.length : 0)\n        var prevKids = (prevState.item.kids ? prevState.item.kids.length : 0)\n        var kidDiff = kids - prevKids\n        if (kidDiff !== 0) {\n          this.threadStore.adjustExpectedComments(kidDiff)\n        }\n      }\n      this.threadStore.itemUpdated(this.state.item)\n    }\n  },\n\n  /**\n   * Ensure the last visit time and comment details get stored for this item if\n   * the user refreshes or otherwise navigates off the page.\n   */\n  handleBeforeUnload() {\n    if (this.threadStore) {\n      this.threadStore.dispose()\n    }\n  },\n\n  handleCommentsChanged(payload) {\n    this.forceUpdate()\n  },\n\n  autoCollapse(e) {\n    e.preventDefault()\n    this.threadStore.collapseThreadsWithoutNewComments()\n  },\n\n  markAsRead(e) {\n    e.preventDefault()\n    this.threadStore.markAsRead()\n    this.forceUpdate()\n  },\n\n  render() {\n    var state = this.state\n    var item = state.item\n    var threadStore = this.threadStore\n    if (!item.id || !threadStore) { return <div className=\"Item Item--loading\"><Spinner size=\"20\"/></div> }\n    return <div className={cx('Item', {'Item--dead': item.dead})}>\n      <div className=\"Item__content\">\n        {this.renderItemTitle(item)}\n        {this.renderItemMeta(item, (threadStore.lastVisit !== null && threadStore.newCommentCount > 0 && <span>{' '}\n          (<em>{threadStore.newCommentCount} new</em> in the last <TimeAgo date={threadStore.lastVisit} formatter={timeUnitsAgo}/>{') | '}\n          <span className=\"control\" tabIndex=\"0\" onClick={this.autoCollapse} onKeyPress={this.autoCollapse} title=\"Collapse threads without new comments\">\n            auto collapse\n          </span>{' | '}\n          <span className=\"control\" tabIndex=\"0\" onClick={this.markAsRead} onKeyPress={this.markAsRead}>\n            mark as read\n          </span>\n        </span>))}\n        {item.text && <div className=\"Item__text\">\n          <div dangerouslySetInnerHTML={{__html: item.text}}/>\n        </div>}\n        {item.type == 'poll' && <div className=\"Item__poll\">\n          {item.parts.map(function(id) {\n            return <PollOption key={id} id={id}/>\n          })}\n        </div>}\n      </div>\n      {item.kids && <div className=\"Item__kids\">\n        {item.kids.map(function(id, index) {\n          return <Comment key={id} id={id} level={0}\n            loadingSpinner={index === 0}\n            threadStore={threadStore}\n          />\n        })}\n      </div>}\n    </div>\n  }\n})\n\nmodule.exports = Item\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Item.jsx\n **/","var React = require('react')\nvar ReactFireMixin = require('reactfire')\n\nvar CommentThreadStore = require('./stores/CommentThreadStore')\nvar HNService = require('./services/HNService')\nvar SettingsStore = require('./stores/SettingsStore')\nvar UpdatesStore = require('./stores/UpdatesStore')\n\nvar Comment = require('./Comment')\nvar CommentMixin = require('./mixins/CommentMixin')\n\nvar cx = require('./utils/buildClassName')\nvar setTitle = require('./utils/setTitle')\n\nvar PermalinkedComment = React.createClass({\n  mixins: [CommentMixin, ReactFireMixin],\n\n  getDefaultProps() {\n    return {\n      level: 0,\n      loadingSpinner: true\n    }\n  },\n\n  getInitialState() {\n    return {\n      comment: UpdatesStore.getComment(this.props.params.id) || {}\n    , parent: {type: 'comment'}\n    , op: {}\n    }\n  },\n\n  componentWillMount() {\n    this.bindAsObject(HNService.itemRef(this.props.params.id), 'comment')\n    if (this.state.comment.id) {\n      this.commentLoaded(this.state.comment)\n    }\n  },\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.params.id != this.props.params.id) {\n      var comment = UpdatesStore.getComment(nextProps.params.id)\n      if (comment) {\n        this.commentLoaded(comment)\n        this.setState({comment: comment})\n      }\n      this.unbind('comment')\n      this.bindAsObject(HNService.itemRef(nextProps.params.id), 'comment')\n    }\n  },\n\n  componentWillUpdate(nextProps, nextState) {\n    if (!nextState.comment) {\n      return\n    }\n\n    if (this.state.comment.id != nextState.comment.id) {\n      if (!nextState.comment.deleted) {\n        // Redirect to the appropriate route if a Comment \"parent\" link had a\n        // non-comment item id.\n        if (nextState.comment.type != 'comment') {\n          this.context.router.replaceWith(nextState.comment.type, {id: nextState.comment.id})\n          return\n        }\n      }\n      if (!this.threadStore || this.threadStore.itemId != nextState.comment.id) {\n        this.commentLoaded(nextState.comment)\n      }\n    }\n  },\n\n  commentLoaded(comment) {\n    this.setTitle(comment)\n    if (!comment.deleted) {\n      this.threadStore = new CommentThreadStore(comment, this.handleCommentsChanged)\n      this.fetchAncestors(comment)\n    }\n  },\n\n  setTitle(comment) {\n    if (comment.deleted) {\n      return setTitle('Deleted comment')\n    }\n    var title = 'Comment by ' + comment.by\n    if (this.state.op.id) {\n      title += ' | ' + this.state.op.title\n    }\n    setTitle(title)\n  },\n\n  handleCommentsChanged(payload) {\n    // We're only interested in re-rendering to update collapsed display\n    if (payload.type == 'collapse') {\n      this.forceUpdate()\n    }\n  },\n\n  render() {\n    var comment = this.state.comment\n    if (!comment) {\n      return this.renderError(comment, {\n        id: this.props.params.id,\n        className: 'Comment Comment--level0 Comment--error'\n      })\n    }\n    // Render a placeholder while we're waiting for the comment to load\n    if (!comment.id) { return this.renderCommentLoading(comment) }\n    // Render a link to HN for deleted comments\n    if (comment.deleted) {\n      return this.renderCommentDeleted(comment, {\n        className: 'Comment Comment--level0 Comment--deleted'\n      })\n    }\n    // XXX Don't render anything if we're replacing the route after loading a non-comment\n    if (comment.type != 'comment') { return null }\n\n    var className = cx('PermalinkedComment Comment Comment--level0', {'Comment--dead': comment.dead})\n    var threadStore = this.threadStore\n\n    return <div className={className}>\n      <div className=\"Comment__content\">\n        {this.renderCommentMeta(comment, {\n          parent: !!this.state.parent.id && !!this.state.op.id && comment.parent != this.state.op.id\n        , op: !!this.state.op.id\n        })}\n        {(!comment.dead || SettingsStore.showDead) && this.renderCommentText(comment, {replyLink: true})}\n      </div>\n      {comment.kids && <div className=\"Comment__kids\">\n        {comment.kids.map(function(id, index) {\n          return <Comment key={id} id={id}\n            level={0}\n            loadingSpinner={index === 0}\n            threadStore={threadStore}\n          />\n        })}\n      </div>}\n    </div>\n  }\n})\n\nmodule.exports = PermalinkedComment\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/PermalinkedComment.jsx\n **/","var React = require('react')\nvar ReactFireMixin = require('reactfire')\n\nvar HNService = require('./services/HNService')\n\nvar Spinner = require('./Spinner')\n\nvar pluralise = require('./utils/pluralise')\n\nvar PollOption = React.createClass({\n  mixins: [ReactFireMixin],\n\n  getInitialState() {\n    return {pollopt: {}}\n  },\n\n  componentWillMount() {\n    this.bindAsObject(HNService.itemRef(this.props.id), 'pollopt')\n  },\n\n  render() {\n    var pollopt = this.state.pollopt\n    if (!pollopt.id) { return <div className=\"PollOption PollOption--loading\"><Spinner size=\"20\"/></div> }\n    return <div className=\"PollOption\">\n      <div className=\"PollOption__text\">\n        {pollopt.text}\n      </div>\n      <div className=\"PollOption__score\">\n        {pollopt.score} point{pluralise(pollopt.score)}\n      </div>\n    </div>\n  }\n})\n\nmodule.exports = PollOption\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/PollOption.jsx\n **/","var React = require('react')\n\nvar SettingsStore = require('./stores/SettingsStore')\n\nvar Settings = React.createClass({\n  componentDidMount() {\n    this.refs.container.getDOMNode().focus()\n  },\n\n  onChange(e) {\n    var el = e.target\n    if (el.type === 'checkbox') {\n      SettingsStore[el.name] = el.checked\n    }\n    else if (el.type === 'number' && el.value) {\n      SettingsStore[el.name] = el.value\n    }\n    this.forceUpdate()\n    SettingsStore.save()\n  },\n\n  onClick(e) {\n    e.stopPropagation()\n  },\n\n  render() {\n    return <div ref=\"container\" className=\"Settings\" tabIndex=\"-1\" onClick={this.onClick}>\n      <form onChange={this.onChange}>\n        <div className=\"Settings__setting Settings__setting--checkbox\">\n          <label htmlFor=\"autoCollapse\">\n            <input type=\"checkbox\" name=\"autoCollapse\" id=\"autoCollapse\" checked={SettingsStore.autoCollapse}/> auto collapse\n          </label>\n          <p>Automatically collapse comment threads without new comments on page load.</p>\n        </div>\n        <div className=\"Settings__setting Settings__setting--checkbox\">\n          <label htmlFor=\"replyLinks\">\n            <input type=\"checkbox\" name=\"replyLinks\" id=\"replyLinks\" checked={SettingsStore.replyLinks}/> show reply links\n          </label>\n          <p>Show \"reply\" links to Hacker News</p>\n        </div>\n        <div className=\"Settings__setting Settings__setting--checkbox\">\n          <label htmlFor=\"showDead\">\n            <input type=\"checkbox\" name=\"showDead\" id=\"showDead\" checked={SettingsStore.showDead}/> show dead\n          </label>\n          <p>Show items flagged as dead.</p>\n        </div>\n        <div className=\"Settings__setting Settings__setting--checkbox\">\n          <label htmlFor=\"showDeleted\">\n            <input type=\"checkbox\" name=\"showDeleted\" id=\"showDeleted\" checked={SettingsStore.showDeleted}/> show deleted\n          </label>\n          <p>Show comments flagged as deleted in threads.</p>\n        </div>\n        <div className=\"Settings__setting\">\n          <table>\n            <tbody>\n              <tr>\n                <td><label htmlFor=\"titleFontSize\">title font size:</label></td>\n                <td><input type=\"number\" min=\"13.333\" step=\"1\" name=\"titleFontSize\" id=\"titleFontSize\" value={SettingsStore.titleFontSize}/></td>\n              </tr>\n              <tr>\n                <td><label htmlFor=\"listSpacing\">list spacing:</label></td>\n                <td><input type=\"number\" min=\"0\" name=\"listSpacing\" id=\"listSpacing\" value={SettingsStore.listSpacing}/></td>\n              </tr>\n            </tbody>\n          </table>\n        </div>\n      </form>\n    </div>\n  }\n})\n\nmodule.exports = Settings\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Settings.jsx\n **/","var React = require('react')\n\nvar StoryStore = require('./stores/StoryStore')\n\nvar PageNumberMixin = require('./mixins/PageNumberMixin')\nvar Paginator = require('./Paginator')\nvar Spinner = require('./Spinner')\nvar StoryListItem = require('./StoryListItem')\nvar SettingsStore = require('./stores/SettingsStore')\n\nvar {ITEMS_PER_PAGE} = require('./utils/constants')\nvar pageCalc = require('./utils/pageCalc')\nvar setTitle = require('./utils/setTitle')\n\nvar Stories = React.createClass({\n  mixins: [PageNumberMixin],\n\n  propTypes: {\n    // The number of stories which may be paginated through\n    limit: React.PropTypes.number.isRequired,\n    // The route name being used\n    route: React.PropTypes.string.isRequired,\n    // The type of stories to be displayed\n    type: React.PropTypes.string.isRequired,\n\n    // Page title associated with the stories being displayed\n    title: React.PropTypes.string\n  },\n\n  getInitialState() {\n    return {\n      ids: [],\n      limit: this.props.limit,\n      stories: []\n    }\n  },\n\n  componentWillMount() {\n    setTitle(this.props.title)\n    this.store = new StoryStore(this.props.type)\n    this.store.addListener('update', this.handleUpdate)\n    this.store.start()\n    this.setState(this.store.getState())\n  },\n\n  componentWillUnmount() {\n    this.store.removeListener('update', this.handleUpdate)\n    this.store.stop()\n    this.store = null\n  },\n\n  handleUpdate(update) {\n    if (!this.isMounted()) {\n      if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\n          `Skipping update as the ${this.props.type} Stories component is no longer mounted.`\n        )\n      }\n      return\n    }\n    update.limit = update.ids.length\n    this.setState(update)\n  },\n\n  render() {\n    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, this.state.limit)\n\n    // Display a list of placeholder items while we're waiting for the initial\n    // list of story ids to load from Firebase.\n    if (this.state.stories.length === 0 && this.state.ids.length === 0) {\n      var dummyItems = []\n      for (var i = page.startIndex; i < page.endIndex; i++) {\n        dummyItems.push(\n          <li key={i} className=\"ListItem ListItem--loading\" style={{marginBottom: SettingsStore.listSpacing}}>\n            <Spinner/>\n          </li>\n        )\n      }\n      return <div className=\"Items Items--loading\">\n        <ol className=\"Items__list\" start={page.startIndex + 1}>{dummyItems}</ol>\n        <Paginator route={this.props.route} page={page.pageNum} hasNext={page.hasNext}/>\n      </div>\n    }\n\n    return <div className=\"Items\">\n      <ol className=\"Items__list\" start={page.startIndex + 1}>\n        {this.renderItems(page.startIndex, page.endIndex)}\n      </ol>\n      <Paginator route={this.props.route} page={page.pageNum} hasNext={page.hasNext}/>\n    </div>\n  },\n\n  renderItems(startIndex, endIndex) {\n    var rendered = []\n    for (var i = startIndex; i < endIndex; i++) {\n      var item = this.state.stories[i]\n      var id = this.state.ids[i]\n      if (id) {\n        rendered.push(<StoryListItem key={id} id={id} index={i} cachedItem={item} store={this.store}/>)\n      }\n      else {\n        rendered.push(<StoryListItem cachedItem={item} store={this.store}/>)\n      }\n    }\n    return rendered\n  }\n})\n\nmodule.exports = Stories\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Stories.jsx\n **/","var React = require('react')\nvar ReactFireMixin = require('reactfire')\n\nvar StoryCommentThreadStore = require('./stores/StoryCommentThreadStore')\nvar HNService = require('./services/HNService')\nvar SettingsStore = require('./stores/SettingsStore')\nvar StoryStore = require('./stores/StoryStore')\n\nvar ItemMixin = require('./mixins/ItemMixin')\nvar ListItemMixin = require('./mixins/ListItemMixin')\nvar Spinner = require('./Spinner')\n\n/**\n * Display story title and metadata as as a list item.\n * Cached story data may be given as a prop, but this component is also\n * responsible for listening to updates to the story and providing the latest\n * version for StoryStore's cache.\n */\nvar StoryListItem = React.createClass({\n  mixins: [ItemMixin, ListItemMixin, ReactFireMixin],\n\n  propTypes: {\n    // The StoryStore handling caching and updates to the stories being displayed\n    store: React.PropTypes.instanceOf(StoryStore).isRequired,\n\n    // The story's id in Hacker News\n    id: React.PropTypes.number,\n    // A version of the story from the cache, for initial display\n    cachedItem: React.PropTypes.object,\n    // The current index of the story in the list being displayed\n    index: React.PropTypes.number\n  },\n\n  getDefaultProps() {\n    return {\n      id: null,\n      cachedItem: null,\n      index: null\n    }\n  },\n\n  getInitialState() {\n    return {\n      item: this.props.cachedItem || {}\n    }\n  },\n\n  componentWillMount() {\n    if (this.props.id != null) {\n      this.initLiveItem(this.props)\n    }\n    else if (this.props.cachedItem != null) {\n      // Display the comment state of the cached item we were given while we're\n      // waiting for the live item to load.\n      this.threadState = StoryCommentThreadStore.loadState(this.state.item.id)\n    }\n  },\n\n  componentWillUnmount() {\n    if (this.props.id != null) {\n      this.props.store.removeListener(this.props.id, this.updateThreadState)\n    }\n  },\n\n  /**\n   * Catch the transition from not having an id prop to having one.\n   * Scenario: we were waiting for the initial list of story ids to load.\n   */\n  componentWillReceiveProps(nextProps) {\n    if (this.props.id == null && nextProps.id != null) {\n      this.initLiveItem(nextProps)\n    }\n  },\n\n  /**\n   * If the live item has been loaded or updated, update the StoryStore cache\n   * with its current index and latest data.\n   */\n  componentWillUpdate(nextProps, nextState) {\n    if (this.state.item !== nextState.item) {\n      if (nextState.item != null) {\n        this.props.store.itemUpdated(nextState.item, this.props.index)\n      }\n      else {\n        if (\"production\" !== process.env.NODE_ENV) {\n          console.warn(`Item ${this.props.id} went from ${JSON.stringify(this.state.item)} to ${nextProps.item}`)\n        }\n      }\n    }\n  },\n\n  /**\n   * Initialise listening to updates for the item with the given id and\n   * initialise its comment thread state.\n   */\n  initLiveItem(props) {\n    // If we were given a cached item to display initially, it will be replaced\n    this.bindAsObject(HNService.itemRef(props.id), 'item')\n    this.threadState = StoryCommentThreadStore.loadState(props.id)\n    this.props.store.addListener(props.id, this.updateThreadState)\n  },\n\n  /**\n   * Update thread state in response to a storage event indicating it has been\n   * modified.\n   */\n  updateThreadState() {\n    this.threadState = StoryCommentThreadStore.loadState(this.props.id)\n    this.forceUpdate()\n  },\n\n  render() {\n    // Display the loading spinner if we have nothing to show initially\n    if (!this.state.item || !this.state.item.id) {\n      return <li className=\"ListItem ListItem--loading\" style={{marginBottom: SettingsStore.listSpacing}}>\n        <Spinner/>\n      </li>\n    }\n\n    return this.renderListItem(this.state.item, this.threadState)\n  }\n})\n\nmodule.exports = StoryListItem\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/StoryListItem.jsx\n **/","var React = require('react')\n\nvar SettingsStore = require('./stores/SettingsStore')\nvar UpdatesStore =  require('./stores/UpdatesStore')\n\nvar DisplayListItem = require('./DisplayListItem')\nvar DisplayComment = require('./DisplayComment')\nvar Paginator = require('./Paginator')\nvar Spinner = require('./Spinner')\n\nvar PageNumberMixin = require('./mixins/PageNumberMixin')\n\nvar {ITEMS_PER_PAGE} = require('./utils/constants')\nvar pageCalc = require('./utils/pageCalc')\nvar setTitle = require('./utils/setTitle')\n\nfunction filterDead(item) {\n  return !item.dead\n}\n\nfunction filterUpdates(updates) {\n  if (!SettingsStore.showDead) {\n    return {\n      comments: updates.comments.filter(filterDead)\n    , stories: updates.stories.filter(filterDead)\n    }\n  }\n  return updates\n}\n\nvar Updates = React.createClass({\n  mixins: [PageNumberMixin],\n\n  getInitialState() {\n    return filterUpdates(UpdatesStore.getUpdates())\n  },\n\n  componentWillMount() {\n    this.setTitle(this.props.type)\n    UpdatesStore.start()\n    UpdatesStore.on('updates', this.handleUpdates)\n  },\n\n  componentWillUnmount() {\n    UpdatesStore.off('updates', this.handleUpdates)\n    UpdatesStore.stop()\n  },\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.type != nextProps.type) {\n      this.setTitle(nextProps.type)\n    }\n  },\n\n  setTitle(type) {\n    setTitle('New ' + (type == 'comments' ? 'Comments' : 'Links'))\n  },\n\n  handleUpdates(updates) {\n    if (!this.isMounted()) {\n      if (\"production\" !== process.env.NODE_ENV) {\n        console.warn('Skipping update of ' + this.props.type + ' as the Updates component is not mounted')\n      }\n      return\n    }\n    this.setState(filterUpdates(updates))\n  },\n\n  render() {\n    var items= (this.props.type == 'comments' ? this.state.comments: this.state.stories)\n    if (items.length === 0) {\n      return <div className=\"Updates Updates--loading\"><Spinner size=\"20\"/></div>\n    }\n\n    var page = pageCalc(this.getPageNumber(), ITEMS_PER_PAGE, items.length)\n\n    if (this.props.type == 'comments') {\n      return <div className=\"Updates Comments\">\n        {items.slice(page.startIndex, page.endIndex).map(function(comment) {\n          return <DisplayComment key={comment.id} id={comment.id} comment={comment}/>\n        })}\n        <Paginator route=\"newcomments\" page={page.pageNum} hasNext={page.hasNext}/>\n      </div>\n    }\n    else {\n      return <div className=\"Updates Items\">\n        <ol className=\"Items__list\" start={page.startIndex + 1}>\n          {items.slice(page.startIndex, page.endIndex).map(function(item) {\n            return <DisplayListItem key={item.id} item={item}/>\n          })}\n        </ol>\n        <Paginator route=\"newest\" page={page.pageNum} hasNext={page.hasNext}/>\n      </div>\n    }\n  }\n})\n\nmodule.exports = Updates\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/Updates.jsx\n **/","var React = require('react')\nvar ReactFireMixin = require('reactfire')\nvar TimeAgo = require('react-timeago')\n\nvar HNService = require('./services/HNService')\n\nvar Spinner = require('./Spinner')\n\nvar setTitle = require('./utils/setTitle')\n\n// TODO User submissions\n\n// TODO User comments\n\nvar UserProfile = React.createClass({\n  mixins: [ReactFireMixin],\n  getInitialState() {\n    return {user: {}}\n  },\n\n  componentWillMount() {\n    this.bindAsObject(HNService.userRef(this.props.params.id), 'user')\n  },\n\n  componentWillUpdate(nextProps, nextState) {\n    if (this.state.user.id != nextState.user.id) {\n      setTitle('Profile: ' + nextState.user.id)\n    }\n  },\n\n  componentWillReceiveProps(nextProps) {\n    if (this.props.params.id != nextProps.params.id) {\n      this.unbind('user')\n      this.bindAsObject(HNService.userRef(nextProps.params.id), 'user')\n    }\n  },\n\n  render() {\n    var user = this.state.user\n    if (!user.id) {\n      return <div className=\"UserProfile UserProfile--loading\">\n        <h4>{this.props.params.id}</h4>\n        <Spinner size=\"20\"/>\n      </div>\n    }\n    var createdDate = new Date(user.created * 1000)\n    return <div className=\"UserProfile\">\n      <h4>{user.id}</h4>\n      <dl>\n        <dt>Created</dt>\n        <dd><TimeAgo date={createdDate}/> ({createdDate.toDateString()})</dd>\n        <dt>Karma</dt>\n        <dd>{user.karma}</dd>\n        <dt>Delay</dt>\n        <dd>{user.delay}</dd>\n        {user.about && <dt>About</dt>}\n        {user.about && <dd><div className=\"UserProfile__about\" dangerouslySetInnerHTML={{__html: user.about}}/></dd>}\n      </dl>\n    </div>\n  }\n})\n\nmodule.exports = UserProfile\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/UserProfile.jsx\n **/","/**\n * Based on the implementation of _.debounce() from Underscore.js 1.7.0\n * http://underscorejs.org\n * (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Distributed under the MIT license.\n *\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing.\n *\n * The returned function has a .cancel() function which can be used to prevent\n * the debounced functiom being called.\n */\nfunction cancellableDebounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result\n\n  var later = function() {\n    var last = Date.now() - timestamp\n    if (last < wait && last > 0) {\n      timeout = setTimeout(later, wait - last)\n    }\n    else {\n      timeout = null\n      if (!immediate) {\n        result = func.apply(context, args)\n        if (!timeout) {\n          context = args = null\n        }\n      }\n    }\n  }\n\n  var debounced = function() {\n    context = this\n    args = arguments\n    timestamp = Date.now()\n    var callNow = immediate && !timeout\n    if (!timeout) {\n      timeout = setTimeout(later, wait)\n    }\n    if (callNow) {\n      result = func.apply(context, args)\n      context = args = null\n    }\n    return result\n  }\n\n  debounced.cancel = function() {\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n  }\n\n  return debounced\n}\n\nmodule.exports = cancellableDebounce\n\n\n\n/** WEBPACK FOOTER **\n ** C:/repos/react-hn/src/utils/cancellableDebounce.js\n **/"],"sourceRoot":""}